
AVRASM ver. 2.2.8  D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm Wed Sep 25 14:56:11 2024

[builtin](2): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\tn2313Adef.inc'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(34): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.inc'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(35): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\decoder.inc'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(36): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\fsm.inc'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(229): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\decoder.asm'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(230): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\fsm.asm'
[builtin](2): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\tn2313Adef.inc'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(34): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.inc'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(35): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\decoder.inc'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(36): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\fsm.inc'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(229): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\decoder.asm'
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\main.asm(230): Including file 'D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\fsm.asm'
                                 
                                 ; ==============================================================================
                                 
                                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny2313A.xml *********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn2313Adef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny2313A
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny2313A
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN2313ADEF_INC_
                                 #define _TN2313ADEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny2313A
                                 #pragma AVRPART ADMIN PART_NAME ATtiny2313A
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x91
                                 .equ	SIGNATURE_002	= 0x0a
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2
                                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	OCR0B	= 0x3c
                                 .equ	GIMSK	= 0x3b
                                 .equ	EIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCSR	= 0x37
                                 .equ	OCR0A	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	TCCR0B	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	TCCR0A	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	CLKPR	= 0x26
                                 .equ	ICR1L	= 0x24
                                 .equ	ICR1H	= 0x25
                                 .equ	GTCCR	= 0x23
                                 .equ	TCCR1C	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	PCMSK0	= 0x20
                                 .equ	EEAR	= 0x1e
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	GPIOR2	= 0x15
                                 .equ	GPIOR1	= 0x14
                                 .equ	GPIOR0	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	USIDR	= 0x0f
                                 .equ	USISR	= 0x0e
                                 .equ	USICR	= 0x0d
                                 .equ	UDR	= 0x0c
                                 .equ	UCSRA	= 0x0b
                                 .equ	UCSRB	= 0x0a
                                 .equ	UBRRL	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	BODCR	= 0x07
                                 .equ	PRR	= 0x06
                                 .equ	PCMSK2	= 0x05
                                 .equ	PCMSK1	= 0x04
                                 .equ	UCSRC	= 0x03
                                 .equ	UBRRH	= 0x02
                                 .equ	DIDR	= 0x01
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	OCIE0A	= 0	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	OCF0A	= 0	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Match Output B Mode
                                 .equ	COM0B1	= 5	; Compare Match Output B Mode
                                 .equ	COM0A0	= 6	; Compare Match Output A Mode
                                 .equ	COM0A1	= 7	; Compare Match Output A Mode
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	TCCR0	= TCCR0B	; For compatibility
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare B
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	ICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
                                 .equ	TICIE	= ICIE1	; For compatibility
                                 .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	ICF1	= 3	; Input Capture Flag 1
                                 .equ	OCF1B	= 5	; Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Output Compare Flag 1A
                                 .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1B0	= 4	; Comparet Ouput Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode Bit 2
                                 .equ	CTC1	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode Bit 3
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1B	= 6	; Force Output Compare for Channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for Channel A
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** USART ************************
                                 ; UDR - USART I/O Data Register
                                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSRA - USART Control and Status Register A
                                 .equ	USR	= UCSRA	; For compatibility
                                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                                 .equ	U2X	= 1	; Double the USART Transmission Speed
                                 .equ	UPE	= 2	; USART Parity Error
                                 .equ	PE	= UPE	; For compatibility
                                 .equ	DOR	= 3	; Data overRun
                                 .equ	FE	= 4	; Framing Error
                                 .equ	UDRE	= 5	; USART Data Register Empty
                                 .equ	TXC	= 6	; USART Transmitt Complete
                                 .equ	RXC	= 7	; USART Receive Complete
                                 
                                 ; UCSRB - USART Control and Status Register B
                                 .equ	UCR	= UCSRB	; For compatibility
                                 .equ	TXB8	= 0	; Transmit Data Bit 8
                                 .equ	RXB8	= 1	; Receive Data Bit 8
                                 .equ	UCSZ2	= 2	; Character Size
                                 .equ	CHR9	= UCSZ2	; For compatibility
                                 .equ	TXEN	= 3	; Transmitter Enable
                                 .equ	RXEN	= 4	; Receiver Enable
                                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSRC - USART Control and Status Register C
                                 .equ	UCPOL	= 0	; Clock Polarity
                                 .equ	UCSZ0	= 1	; Character Size Bit 0
                                 .equ	UCSZ1	= 2	; Character Size Bit 1
                                 .equ	USBS	= 3	; Stop Bit Select
                                 .equ	UPM0	= 4	; Parity Mode Bit 0
                                 .equ	UPM1	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0 	= 6	; USART Mode Select 0
                                 .equ 	UMSEL1 	= 7 ; USART Mode Select 1
                                 .equ 	UCPHA  	= 1 ; USART MSPIM Clock Phase
                                 .equ 	UDORD  	= 2 ; USART MSPIM Data Order 
                                 
                                 .equ	UBRR	= UBRRL	; For compatibility
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; 
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Data Register, Port D
                                 .equ	PORTD0	= 0	; 
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; 
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; 
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; 
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; 
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; 
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; 
                                 .equ	PD6	= 6	; For compatibility
                                 
                                 ; DDRD - Data Direction Register, Port D
                                 .equ	DDD0	= 0	; 
                                 .equ	DDD1	= 1	; 
                                 .equ	DDD2	= 2	; 
                                 .equ	DDD3	= 3	; 
                                 .equ	DDD4	= 4	; 
                                 .equ	DDD5	= 5	; 
                                 .equ	DDD6	= 6	; 
                                 
                                 ; PIND - Input Pins, Port D
                                 .equ	PIND0	= 0	; 
                                 .equ	PIND1	= 1	; 
                                 .equ	PIND2	= 2	; 
                                 .equ	PIND3	= 3	; 
                                 .equ	PIND4	= 4	; 
                                 .equ	PIND5	= 5	; 
                                 .equ	PIND6	= 6	; 
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEAR - EEPROM Read/Write Access
                                 .equ	EEARL	= EEAR	; For compatibility
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access bit 6
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEWE	= EEPE	; For compatibility
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EEMWE	= EEMPE	; For compatibility
                                 .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; 
                                 .equ	EEPM1	= 5	; 
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 
                                 
                                 ; ***** USI **************************
                                 ; USIDR - USI Data Register
                                 .equ	USIDR0	= 0	; USI Data Register bit 0
                                 .equ	USIDR1	= 1	; USI Data Register bit 1
                                 .equ	USIDR2	= 2	; USI Data Register bit 2
                                 .equ	USIDR3	= 3	; USI Data Register bit 3
                                 .equ	USIDR4	= 4	; USI Data Register bit 4
                                 .equ	USIDR5	= 5	; USI Data Register bit 5
                                 .equ	USIDR6	= 6	; USI Data Register bit 6
                                 .equ	USIDR7	= 7	; USI Data Register bit 7
                                 
                                 ; USISR - USI Status Register
                                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                                 .equ	USIDC	= 4	; Data Output Collision
                                 .equ	USIPF	= 5	; Stop Condition Flag
                                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                                 
                                 ; USICR - USI Control Register
                                 .equ	USITC	= 0	; Toggle Clock Port Pin
                                 .equ	USICLK	= 1	; Clock Strobe
                                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; GIMSK - General Interrupt Mask Register
                                 .equ  PCIE1 = 3 ;
                                 .equ  PCIE2 = 4 ;
                                 .equ	PCIE0	= 5	; 
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; EIFR - Extended Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	PCIF0	= 5	; 
                                 .equ  PCIF2	= 4   ;
                                 .equ  PCIF1   = 3   ;
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; PCMSK2 - Pin Change Interrupt Mask Register 2
                                 .equ	PCINT11	= 0	; Pin Change Interrupt Mask 11
                                 .equ	PCINT12	= 1	; Pin Change Interrupt Mask 12
                                 .equ	PCINT13	= 2	; Pin Change Interrupt Mask 13
                                 .equ	PCINT14	= 3	; Pin Change Interrupt Mask 14
                                 .equ	PCINT15	= 4	; Pin Change Interrupt Mask 15
                                 .equ	PCINT16	= 5	; Pin Change Interrupt Mask 16
                                 .equ	PCINT17	= 6	; Pin Change Interrupt Mask 17
                                 
                                 ; PCMSK1 - Pin Change Interrupt Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Interrupt Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Interrupt Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Interrupt Mask 10
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; SPMCSR - Store Program Memory Control and Status register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	RFLB	= 3	; Read Fuse and Lock Bits
                                 .equ	CTPB	= 4	; Clear Temporary Page Buffer
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 0
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
                                 .equ	SM0	= 4	; Sleep Mode Select Bit 0
                                 .equ	SM	= SM0	; For compatibility
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SM1	= 6	; Sleep Mode Select Bit 1
                                 .equ	PUD	= 7	; Pull-up Disable
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; MCUSR - MCU Status register
                                 .equ	PORF	= 0	; Power-On Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Register
                                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                                 
                                 ; GTCCR - General Timer Counter Control Register
                                 .equ	SFIOR	= GTCCR	; For compatibility
                                 .equ	PSR10	= 0	; 
                                 
                                 ; PCMSK - Pin-Change Mask register
                                 .equ	PCINT0	= 0	; Pin-Change Interrupt 0
                                 .equ	PCINT1	= 1	; Pin-Change Interrupt 1
                                 .equ	PCINT2	= 2	; Pin-Change Interrupt 2
                                 .equ	PCINT3	= 3	; Pin-Change Interrupt 3
                                 .equ	PCINT4	= 4	; Pin-Change Interrupt 4
                                 .equ	PCINT5	= 5	; Pin-Change Interrupt 5
                                 .equ	PCINT6	= 6	; Pin-Change Interrupt 6
                                 .equ	PCINT7	= 7	; Pin-Change Interrupt 7
                                 
                                 ; GPIOR2 - General Purpose I/O Register 2
                                 .equ	GPIOR20	= 0	; General Purpose I/O Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose I/O Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose I/O Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose I/O Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose I/O Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose I/O Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose I/O Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose I/O Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose I/O Register 1
                                 .equ	GPIOR10	= 0	; General Purpose I/O Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose I/O Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose I/O Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose I/O Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose I/O Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose I/O Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose I/O Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose I/O Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose I/O Register 0
                                 .equ	GPIOR00	= 0	; General Purpose I/O Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose I/O Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose I/O Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose I/O Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose I/O Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose I/O Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose I/O Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose I/O Register 0 bit 7
                                 
                                 ; PRR - Power reduction register
                                 .equ	PRUSART	= 0	; 
                                 .equ	PRUSI	= 1	; 
                                 .equ	PRTIM0	= 2	; 
                                 .equ	PRTIM1	= 3	; 
                                 
                                 ; BODCR - BOD control register
                                 .equ	BPDSE	= 0	; 
                                 .equ	BPDS	= 1	; 
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog Timer Always On
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	DWEN	= 6	; debugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x03ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 128
                                 .equ	RAMEND	= 0x00df
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x007f
                                 .equ	EEPROMEND	= 0x007f
                                 .equ	EEADRBITS	= 7
                                 #pragma AVRPART MEMORY PROG_FLASH 2048
                                 #pragma AVRPART MEMORY EEPROM 128
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 128
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x0
                                 .equ	NRWW_STOP_ADDR	= 0x3ff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x0
                                 .equ	PAGESIZE	= 16
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                                 .equ	ICP1addr	= 0x0003	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0004	; Timer/Counter1 Compare Match A
                                 .equ	OC1addr	= 0x0004	; For compatibility
                                 .equ	OVF1addr	= 0x0005	; Timer/Counter1 Overflow
                                 .equ	OVF0addr	= 0x0006	; Timer/Counter0 Overflow
                                 .equ	URXCaddr	= 0x0007	; USART, Rx Complete
                                 .equ	URXC0addr	= 0x0007	; For compatibility
                                 .equ	UDREaddr	= 0x0008	; USART Data Register Empty
                                 .equ	UDRE0addr	= 0x0008	; For compatibility
                                 .equ	UTXCaddr	= 0x0009	; USART, Tx Complete
                                 .equ	UTXC0addr	= 0x0009	; For compatibility
                                 .equ	ACIaddr	= 0x000a	; Analog Comparator
                                 .equ	PCIBaddr	= 0x000b	; Pin Change Interrupt Request B
                                 .equ	PCIaddr	= 0x000b	; For compatibility
                                 .equ	OC1Baddr	= 0x000c	; 
                                 .equ	OC0Aaddr	= 0x000d	; 
                                 .equ	OC0Baddr	= 0x000e	; 
                                 .equ	USI_STARTaddr	= 0x000f	; USI Start Condition
                                 .equ	USI_OVFaddr	= 0x0010	; USI Overflow
                                 .equ	ERDYaddr	= 0x0011	; 
                                 .equ	WDTaddr	= 0x0012	; Watchdog Timer Overflow
                                 .equ	PCIAaddr	= 0x0013	; Pin Change Interrupt Request A
                                 .equ	PCIDaddr	= 0x0014	; Pin Change Interrupt Request D
                                 
                                 .equ	INT_VECTORS_SIZE	= 21	; size in words
                                 
                                 #endif  /* _TN2313ADEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;  TITLE           : Startampel "Bären(n)keller"
                                 ; ==============================================================================
                                 ;  HW-VERSION      : 1.xx
                                 ;  SW-VERSION      : 1.0
                                 ;  SW-DATE         : 2024-01-17 (jjjj-mm-dd)
                                 ;  SW-AUTHOR       : Andreas Wahl - 73642 Welzheim - Germany
                                 ;                  : https://www.andreas-wahl.de
                                 ;  LICENSE         : GNU AFFERO GENERAL PUBLIC LICENSE
                                 ;                  : Version 3, 2007-11-19
                                 ;                  : https://www.gnu.org/licenses/
                                 ; ==============================================================================
                                 ;  CONTROLLER      : Microchip / Atmel ATtiny 2313(A)
                                 ;                    https://www.microchip.com/en-us/product/ATtiny2313
                                 ;  CLOCK           : 8 MHZ, internal system clock, (INTRCOSC_8MHZ_14CK_65MS)
                                 ;  RESET           : internal power-on reset
                                 ;  BOD             : internal, 4.3V
                                 ;  INTERRUPT USAGE : EXT INT0 (PD2), 8-bit TIMER0 (Manchester time elapsed)
                                 ;                  : 16-bit TIMER1 (led blink frequency)
                                 ;  I/O USAGE IN    : PD2 = Input signal Carrera Manchester code
                                 ;  I/O USAGE OUT   : PB0 = LED yellow, PB1 = LED green /
                                 ;                  : PB2 = LED red 5, PB3 = LED red 4, PB4 = LED red 3
                                 ;                  : PB5 = LED red 2, PB6 = LED red 1
                                 ;                  : PD5 = Debug pin/LED red, PD6 = Debug pin/LED yellow
                                 ; ==============================================================================
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  INCLUDES / DECLARATIONS
                                 ; ------------------------------------------------------------------------------
                                 .LIST
                                     .INCLUDE "main.inc"
                                 
                                 ;  INCLUDE TITLE   : Startampel "Bären(n)keller"
                                 ;  INCLUDE TYPE    : X DECLARATIONS    - CODE
                                 ; ==============================================================================
                                 ;  FILE            : main.inc
                                 ;  SW-VERSION      : 1.0
                                 ;  SW-DATE         : 2024-01-17 (jjjj-mm-dd)
                                 ;  SW-AUTHOR       : Andreas Wahl - 73642 Welzheim - Germany
                                 ;                  : https://www.andreas-wahl.de
                                 ;  LICENSE         : GNU AFFERO GENERAL PUBLIC LICENSE
                                 ;                  : Version 3, 2007-11-19
                                 ;                  : https://www.gnu.org/licenses/
                                 ; ==============================================================================
                                 
                                 ; ==============================================================================
                                 ;  CONFIGURATION
                                 ; ==============================================================================
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  CLOCK CONFIGURATION
                                 ; ------------------------------------------------------------------------------
                                 .EQU    F_CPU       =   8000000             ; Systemclock in Hz
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  TIMER1 SETTINGS
                                 ;
                                 ;  Setup TIMER1 to trigger every 500ms (2Hz).
                                 ; ------------------------------------------------------------------------------
                                 
                                 ; For 8 MHz system clock set prescaler to system clock/64.
                                 ; --> 8us (125kHz)
                                 .EQU    cfgTIMER1_CS10     =   1
                                 .EQU    cfgTIMER1_CS11     =   1
                                 .EQU    cfgTIMER1_CS12     =   0
                                 
                                 ; Value for preloading counter to reach 2Hz (500ms) timer clock.
                                 .EQU    cfgTIMER1_TCNT1    =   18661
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  REGISTER CONFIGURATION
                                 ; ------------------------------------------------------------------------------
                                 ; Register for short-term/temporary use. Immediate access is required.
                                 
                                 ; Comprehensive use.
                                 .DEF    rAccu               =   R16     ; Working register
                                 .DEF    rScratch            =   R17     ; Temporary register
                                 .DEF    rTransfer           =   R18     ; Transfer register
                                 
                                 ; Used by decoder.
                                 .DEF    rDecoderState       =   R19     ; Decoder status flag register
                                 .DEF    rTimeElapsedCnt     =   R20     ; Counter register to count elapsed time
                                                                         ; between edge chances in 10us steps.
                                                                         ; Used by Timer0 interrupt from decoder
                                 ; Used by finite state machine..
                                 .DEF    rFsmRacing          =   R21     ; marks the state of the race for 
                                                                         ; further decision on the chaos phase by 
                                                                         ; the state machine
                                 
                                 ; Register for long-term use. Immediate access is not required.
                                 ; For possible special use e.g. multiplications always skip R0 and R1.
                                 
                                 ; Used by decoder.
                                 .DEF    rReceivedByteL      =   R2      ; Received Manchester bits
                                 .DEF    rReceivedByteH      =   R3      ; Received Manchester bits
                                 .DEF    rReceivedBitCnt     =   R4      ; Counter for received bits
                                 .DEF    rReceivedPacketCnt    =   R5      ; Counter for received datapacket
                                 
                                 ; Used by finite state machine.
                                 .DEF    rFsmCurrentState    =   R6      ; Current state, used by state machine
                                 .DEF    rFsmNextState       =   R7      ; Next state, used by state machine
                                 
                                 ; Used by main and finite state machine.
                                 .DEF    rBlinkMask          =   R8  ; Register to mask blinking LEDs
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  PORT and PIN CONFIGURATION
                                 ; ------------------------------------------------------------------------------
                                 ; Inputs: Carrera manchester code.
                                 .EQU    ioCMCport          =   PORTD        ; Input port
                                 .EQU    ioCMCpin           =   PIND         ; Input port/pin
                                 .EQU    ioCMCddr           =   DDRD         ; DDR of input port
                                 .EQU    ioCMCsignal        =   PIND2        ; Input pin/bit: Manchester signal
                                 
                                 ; Outputs: Startlights.
                                 .EQU    ioLEDport          =   PORTB        ; LED output port
                                 .EQU    ioLEDddr           =   DDRB         ; DDR of LED output port
                                 .EQU    ioLEDred1          =   PINB6        ; Port-pin/bit: LED column red 1
                                 .EQU    ioLEDred2          =   PINB5        ; Port-pin/bit: LED column red 2
                                 .EQU    ioLEDred3          =   PINB4        ; Port-pin/bit: LED column red 3
                                 .EQU    ioLEDred4          =   PINB3        ; Port-pin/bit: LED column red 4
                                 .EQU    ioLEDred5          =   PINB2        ; Port-pin/bit: LED column red 5
                                 .EQU    ioLEDgreen         =   PINB1        ; Port-pin/bit: LED row green
                                 .EQU    ioLEDyellow        =   PINB0        ; Port-pin/bit: LED row yellow
                                 
                                 ; Outputs: Earlystart.
                                 .EQU    ioEarlyStart1st    =   ioLEDred1    ; Start pin (bit) to display
                                                                             ; slotcar with earlystart
                                                                             ; (default = ioLEDred1)
                                 .EQU    ioEarlyStartDir    =   0            ; slotcar number rotation
                                                                             ; (0=right [default], 1=left)
                                 
                                 ; * * * * * D E B U G * * * * *
                                 ; Outputs: Debug pins.
                                 .EQU    ioDEBUGport         =   PORTD
                                 .EQU    ioDEBUGpin          =   PIND
                                 .EQU    ioDEBUGddr          =   DDRD
                                 .EQU    ioDEBUGred          =   PIND5
                                 .EQU    ioDEBUGyellow       =   PIND6
                                 ; * * * * * D E B U G * * * * *
                                 
                                 ; ==============================================================================
                                 ;  MACROS
                                 ; ==============================================================================
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  TIMER1
                                 ;
                                 ;  The interrupt is triggered every 500ms and toggles the port-pins defined
                                 ;  in the blink register (rBlinkMask).
                                 ; ------------------------------------------------------------------------------
                                 
                                 .MACRO mac_MAIN_TIMER1init
                                     ; --------------------------------------------------------------------------
                                     ; Initialize TIMER1 to blink LEDs.
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Configure prescaler.
                                     ldi     rAccu,  (cfgTIMER1_CS12 << CS12) | (cfgTIMER1_CS11 << CS11) | (cfgTIMER1_CS10 << CS10)
                                     out     TCCR1B,  rAccu
                                 
                                     ; Preload counter.
                                     ldi     rAccu, HIGH(cfgTIMER1_TCNT1)
                                     out     TCNT1H, rAccu
                                     ldi     rAccu, LOW(cfgTIMER1_TCNT1)
                                     out     TCNT1L, rAccu
                                 
                                     ; Clear blink register.
                                     clr rBlinkMask
                                 .ENDMACRO
                                 
                                 .MACRO mac_MAIN_TIMER1start
                                     ; --------------------------------------------------------------------------
                                     ; Start / Enable TIMER1.
                                     ; --------------------------------------------------------------------------
                                     in      rAccu, TIMSK        ; Read current state
                                     sbr     rAccu, 1<<TOIE1     ; Enable TIMER1
                                     out     TIMSK, rAccu        ; Write new state
                                 .ENDMACRO
                                 
                                 .MACRO mac_MAIN_TIMER1stop
                                     ; --------------------------------------------------------------------------
                                     ; Stop / Disable TIMER1.
                                     ; --------------------------------------------------------------------------
                                     in      rAccu, TIMSK        ; Read current state
                                     sbr     rAccu, 0<<TOIE1     ; Enable TIMER1
                                     out     TIMSK, rAccu        ; Write new state
                                 .ENDMACRO
                                 
                                 .MACRO mac_MAIN_TIMER1restart
                                     ; --------------------------------------------------------------------------
                                     ; Restart TIMER1.
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Stop TIMER1.
                                     mac_MAIN_TIMER1stop
                                 
                                     ; Preload counter for 2Hz (500ms) timer clock.
                                     ldi     rAccu, HIGH(cfgTIMER1_TCNT1)
                                     out     TCNT1H, rAccu
                                     ldi     rAccu, LOW(cfgTIMER1_TCNT1)
                                     out     TCNT1L, rAccu
                                 
                                     ; Start TIMER1.
                                     mac_MAIN_TIMER1start
                                 .ENDMACRO
                                 
                                     .INCLUDE "decoder.inc"
                                 
                                 ;  INCLUDE TITLE   : Manchester Decoder for Carrera Digital 124/132
                                 ;  INCLUDE TYPE    : X DECLARATIONS    - CODE
                                 ; ==============================================================================
                                 ;  FILE            : decoder.inc
                                 ;  MAIN TITLE      : Startampel "BÃ¤ren(n)keller"
                                 ;  MAIN FILE       : main.asm + main.inc
                                 ;  SW-VERSION      : 1.0
                                 ;  SW-DATE         : 2024-01-17 (jjjj-mm-dd)
                                 ;  SW-AUTHOR       : Andreas Wahl - 73642 Welzheim - Germany
                                 ;                  : https://www.andreas-wahl.de
                                 ;  LICENSE         : GNU AFFERO GENERAL PUBLIC LICENSE
                                 ;                  : Version 3, 2007-11-19
                                 ;                  : https://www.gnu.org/licenses/
                                 ; ==============================================================================
                                 
                                 ; ==============================================================================
                                 ;  CONFIGURATION
                                 ; ==============================================================================
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  TIMER0 SETTINGS
                                 ;
                                 ;  Setup TIMER0 to trigger every 10us (100kHz).
                                 ; ------------------------------------------------------------------------------
                                 
                                 ; For 8 MHz system clock set no prescaling (system clock/1).
                                 ; 8MHz system clock (125ns) --> timer clock 31.25 kHz (32us) @ TCNT=0 (to 255).
                                 .EQU    cfgTIMER0_CS00     =   1
                                 .EQU    cfgTIMER0_CS01     =   0
                                 .EQU    cfgTIMER0_CS02     =   0
                                 
                                 ; Value for preloading counter to reach 100kHz (10us) timer clock.
                                 .EQU    cfgTIMER0_TCNT0    =   195
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  CONSTANTS
                                 ; ------------------------------------------------------------------------------
                                 ; SRAM dataspace.
                                 .EQU    cfgSRAM_DwSize      =   44              ; Reserve SRAM memory for
                                                                                 ; decoded datapackets (11x4Byte).
                                 
                                 ; SRAM pointer offsets.
                                 .EQU    pStartProgCU        =    0              ; Start prog-data/CU-datapacket
                                 .EQU    pStartPGC           =    4              ; Start pace/ghostcar datapacket
                                 .EQU    pStartAckn          =    8              ; Start acknowledge-datapacket
                                 .EQU    pStartCtrl0         =   12              ; Start controller 0 / slotcar 0
                                 .EQU    pStartCtrl4         =   16              ; Start controller 4 / slotcar 4
                                 .EQU    pStartCtrl1         =   20              ; Start controller 1 / slotcar 1
                                 .EQU    pStartCtrl5         =   24              ; Start controller 5 / slotcar 5
                                 .EQU    pStartCtrl2         =   28              ; Start controller 2 / slotcar 2
                                 .EQU    pStartActive        =   32              ; Start active datapacket
                                 .EQU    pStartCtrl3         =   36              ; Start controller 3 / slotcar 3
                                 .EQU    pStartDebug         =   40              ; Start debugging only
                                 
                                 .EQU    pOffsetDpPos        =    0              ; +0: Offset position/no.
                                 .EQU    pOffsetDpCnt        =    1              ; +1: Offset length
                                 .EQU    pOffsetDpLow        =    2              ; +2: Offset low byte
                                 .EQU    pOffsetDpHigh       =    3              ; +3: Offset high byte
                                 
                                 ; Carrera datapacket length.
                                 .EQU    flProgDpLength      =   12              ; Programming datapacket (12Bit)
                                 .EQU    flPgcDpLength       =    9              ; Pace/ghostcar datapacket (9Bit)
                                 .EQU    flActDpLength       =    7              ; Active datapacket (7Bit)
                                 .EQU    flCtrlDpLength      =    9              ; Controller datapacket (9Bit)
                                 .EQU    flAckDpLength       =    8              ; Acknowledge datapacket (8Bit)
                                 
                                 ; Decoder status flags.
                                 .EQU    flTransmComplete    =   0               ; Transmission completed
                                 .EQU    flDataEvaluated     =   1               ; Data evaluated
                                 
                                 ; Decoder check results.
                                 .EQU    mskProgValues       =   0b00000111      ; Position of values
                                 .EQU    flProgFinished      =   3               ; Contains startlights
                                 .EQU    flProgStartLights   =   4               ; Contains startlights
                                 .EQU    flProgEarlyStart    =   5               ; Early start detected
                                 .EQU    flProgPaceCar       =   6               ; Pacecar detected
                                 .EQU    flProgReset         =   7               ; Reset detected
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  CHECK REQUIREMENTS
                                 ; ------------------------------------------------------------------------------
                                 
                                 ; The following registers must be defined in the main program:
                                 ; ------------------------------------------------------------------------------
                                 ; .DEF    rReceivedByteL      =   (R2)      ; Received Manchester bits
                                 ; .DEF    rReceivedByteH      =   (R3)      ; Received Manchester bits
                                 ; .DEF    rReceivedBitCnt     =   (R4)      ; Counter for received bits
                                 ; .DEF    rReceivedPacketCnt  =   (R5)      ; Counter for received datapackets
                                 ; .DEF    rDecoderState       =   (R19)     ; Decoder status flag register
                                 ; .DEF    rTimeElapsedCnt     =   (R20)     ; Counter register to count elapsed time
                                 ;                                           ; between edge chances in 10us steps.
                                 ;                                           ; Used by Timer0 interrupt from decoder
                                 
                                 
                                 .IF F_CPU != 8000000
                                 .ENDIF
                                 
                                 .IFNDEF rAccu
                                 .ENDIF
                                 
                                 .IFNDEF rScratch
                                 .ENDIF
                                 
                                 .IFNDEF rTransfer
                                 .ENDIF
                                 
                                 .IFNDEF rDecoderState
                                 .ENDIF
                                 
                                 .IFNDEF rTimeElapsedCnt
                                 .ENDIF
                                 
                                 .IFNDEF rReceivedByteL
                                 .ENDIF
                                 
                                 .IFNDEF rReceivedByteH
                                 .ENDIF
                                 
                                 .IFNDEF rReceivedBitCnt
                                 .ENDIF
                                 
                                 .IFNDEF rReceivedPacketCnt
                                 .ENDIF
                                 
                                 .IFNDEF ioCMCpin
                                 .ENDIF
                                 
                                 .IFNDEF ioCMCsignal
                                 .ENDIF
                                 
                                 ; ==============================================================================
                                 ;  MACROS
                                 ; ==============================================================================
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  RANDOM ACCESS MEMORY / SRAM
                                 ; ------------------------------------------------------------------------------
                                 .MACRO mac_DECODER_SRAMclear
                                     ; --------------------------------------------------------------------------
                                     ;  CLEAR SRAM
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Load counter with SRAM size.
                                     ldi     rScratch, cfgSRAM_DwSize
                                 
                                     ; Load pointer with SRAM address.
                                     ldi     ZL, LOW (SRAM_DataPackets)
                                     ldi     ZH, HIGH (SRAM_DataPackets)
                                 
                                     ; Clear SRAM byte and increment pointer.
                                     clr     rAccu
                                 
                                 DECODER_ClearSRAM:
                                     st      Z+, rAccu
                                 
                                     ; Decrement counter and loop until counter=0.
                                     dec     rScratch
                                     tst     rScratch
                                     brne    DECODER_ClearSRAM
                                 .ENDMACRO
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  TIMER0
                                 ;
                                 ;  The interrupt is triggered every 10us and increases a counter by 1.
                                 ;  Within the ISR INT0, the elapsed time between the edge changes of the
                                 ;  carrera manchester code can be measured by evaluating the counter value.
                                 ; ------------------------------------------------------------------------------
                                 .MACRO mac_DECODER_TIMER0init
                                     ; --------------------------------------------------------------------------
                                     ; Initialize TIMER0 for manchester clock check.
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Configure prescaler.
                                     ldi     rAccu,  (cfgTIMER0_CS02 << CS02) | (cfgTIMER0_CS01 << CS01) | (cfgTIMER0_CS00 << CS00)
                                     out     TCCR0,  rAccu
                                 
                                     ; Preload counter.
                                     ldi     rAccu, cfgTIMER0_TCNT0
                                     out     TCNT0, rAccu
                                 
                                 .ENDMACRO
                                 
                                 .MACRO mac_DECODER_TIMER0start
                                     ; --------------------------------------------------------------------------
                                     ; Start / Enable TIMER0
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Clear time elapsed counter
                                     clr     rTimeElapsedCnt
                                 
                                     ; Start Timer
                                     in      rAccu, TIMSK        ; Read current state
                                     sbr     rAccu, (1<<TOIE0)   ; Enable TIMER0-interrupt
                                     out     TIMSK, rAccu        ; Write new state
                                 
                                     ; * * * * * D E B U G * * * * *
                                     ; Outputs: Frame-start to debug led.
                                     ; sbi     ioDEBUGport, ioDEBUGyellow
                                     ; * * * * * D E B U G * * * * *
                                 
                                 .ENDMACRO
                                 
                                 .MACRO mac_DECODER_TIMER0stop
                                     ; --------------------------------------------------------------------------
                                     ; Stop / disable TIMER0
                                     ; --------------------------------------------------------------------------
                                     in      rAccu, TIMSK        ; Read current state
                                     cbr     rAccu, (1<<TOIE0)   ; Disable TIMER0-interrupt
                                     out     TIMSK, rAccu        ; Write new state
                                 
                                     ; * * * * * D E B U G * * * * *
                                     ; Outputs: Frame-end to debug led.
                                     ; cbi     ioDEBUGport, ioDEBUGyellow
                                     ; * * * * * D E B U G * * * * *
                                 
                                 .ENDMACRO
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  EXTERNAL INTERRUPT INT0
                                 ;
                                 ;  The interrupt is triggered every edge change of the carrera manchester code.
                                 ;  Together with the counter from TIMER0, the carrera manchester code
                                 ;  will be decoded and the received bits are stored in the receive registers
                                 ;  (2 Byte).
                                 ; ------------------------------------------------------------------------------
                                 .MACRO mac_DECODER_INT0init
                                     ; --------------------------------------------------------------------------
                                     ; Initialize external interrupt INT0 (PD2)
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Clear depending registers and counter.
                                     clr     rReceivedByteL
                                     clr     rReceivedByteH
                                     clr     rReceivedBitCnt
                                     clr     rReceivedPacketCnt
                                 
                                     ; Any logical change on PD2(INT0) generates an interrupt request.
                                     in      rAccu, MCUCR        ; Read current state
                                     cbr     rAccu, (1<<ISC01)   ; ISC01 = 0
                                     sbr     rAccu, (1<<ISC00)   ; ISC00 = 1
                                     out     MCUCR, rAccu        ; Write new state
                                 .ENDMACRO
                                 
                                 .MACRO mac_DECODER_INT0start
                                     ; --------------------------------------------------------------------------
                                     ; Start / enable external interrupt INT0
                                     ; --------------------------------------------------------------------------
                                     in      rAccu, GIMSK        ; Read current state
                                     sbr     rAccu, (1<<INT0)    ; Enable INT0
                                     out     GIMSK, rAccu        ; Write new state
                                 .ENDMACRO
                                 
                                 .MACRO mac_DECODER_INT0stop
                                     ; --------------------------------------------------------------------------
                                     ; Stop / disable external interrupt INT0
                                     ; --------------------------------------------------------------------------
                                     in      rAccu, GIMSK        ; Read current state
                                     cbr     rAccu, (1<<INT0)    ; Disable INT0
                                     out     GIMSK, rAccu        ; Write new state
                                 .ENDMACRO
                                     .INCLUDE "fsm.inc"
                                 
                                 ;  INCLUDE TITLE   : Finite-State Machine (FSM)
                                 ;  INCLUDE TYPE    : X DECLARATIONS    - CODE
                                 ; ==============================================================================
                                 ;  FILE            : state.inc
                                 ;  MAIN TITLE      : Startampel "Bären(n)keller"
                                 ;  MAIN FILE       : main.asm + main.inc
                                 ;  SW-VERSION      : 1.0
                                 ;  SW-DATE         : 2024-01-17 (jjjj-mm-dd)
                                 ;  SW-AUTHOR       : Andreas Wahl - 73642 Welzheim - Germany
                                 ;                  : https://www.andreas-wahl.de
                                 ;  LICENSE         : GNU AFFERO GENERAL PUBLIC LICENSE
                                 ;                  : Version 3, 2007-11-19
                                 ;                  : https://www.gnu.org/licenses/
                                 ; ==============================================================================
                                 
                                 ; ==============================================================================
                                 ;  CONFIGURATION
                                 ; ==============================================================================
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  CONSTANTS
                                 ; ------------------------------------------------------------------------------
                                 
                                 ; FSM State-Numbers.
                                 .EQU    fsmState0Init = 0       ; Waiting for data
                                 .EQU    fsmState1Red1 = 1       ; Countdown 1
                                 .EQU    fsmState2Red2 = 2       ; Countdown 2
                                 .EQU    fsmState3Red3 = 3       ; Countdown 3
                                 .EQU    fsmState4Red4 = 4       ; Countdown 4
                                 .EQU    fsmState5Red5 = 5       ; Countdown 5 - (re-)start - chaos
                                 .EQU    fsmState6Grn  = 6       ; Race
                                 .EQU    fsmState7Yel1 = 7       ; Pacecar
                                 .EQU    fsmState8Yel2 = 8       ; Early start
                                 .EQU    fsmState9RFin = 9       ; Race finished
                                 .EQU    fsmState10Chaos = 10      ; CHAOS
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  CHECK REQUIREMENTS
                                 ; ------------------------------------------------------------------------------
                                 
                                 ; The following registers must be defined in the main program:
                                 ; ------------------------------------------------------------------------------
                                 ; .DEF    rFsmCurrentState    =   (R6)      ; Current state, used by state machine
                                 ; .DEF    rFsmNextState       =   (R7)      ; Next state, used by state machine
                                 ; .DEF    rBlinkMask          =   (R8)      ; Register to mask blinking LEDs
                                 ; .DEF    rFsmRacing          =   (R21)     ; marks the state of the race for 
                                                                             ; further decision on the chaos phase by 
                                                                             ; the state machine
                                 
                                 .IFNDEF rAccu
                                 .ENDIF
                                 
                                 .IFNDEF rScratch
                                 .ENDIF
                                 
                                 .IFNDEF rTransfer
                                 .ENDIF
                                 
                                 .IFNDEF rBlinkMask
                                 .ENDIF
                                 
                                 .IFNDEF rFsmCurrentState
                                 .ENDIF
                                 
                                 .IFNDEF rFsmNextState
                                 .ENDIF
                                 
                                 .IFNDEF rFsmRacing
                                 .ENDIF
                                 
                                 .IFNDEF ioLEDport
                                 .ENDIF
                                 
                                 .IFNDEF ioLEDred1
                                 .ENDIF
                                 
                                 .IFNDEF ioLEDred2
                                 .ENDIF
                                 
                                 .IFNDEF ioLEDred3
                                 .ENDIF
                                 
                                 .IFNDEF ioLEDred4
                                 .ENDIF
                                 
                                 .IFNDEF ioLEDred5
                                 .ENDIF
                                 
                                 .IFNDEF ioLEDgreen
                                 .ENDIF
                                 
                                 .IFNDEF ioLEDyellow
                                 .ENDIF
                                 
                                 .IFNDEF ioEarlyStart1st
                                 .ENDIF
                                 
                                 .IFNDEF ioEarlyStartDir
                                 .ENDIF
                                 
                                 ; ==============================================================================
                                 ;  MACROS
                                 ; ==============================================================================
                                 
                                 ; ==============================================================================
                                 ;  RANDOM ACCESS MEMORY / SRAM
                                 ; ==============================================================================
                                 .DSEG
000060                               SRAM_DataPackets:     .byte cfgSRAM_DwSize      ; Data space for datapackets
                                                                                     ; See "decoder.inc"
                                 
                                 ; ==============================================================================
                                 ;  PROGRAM MEMORY
                                 ; ==============================================================================
                                 .CSEG                                   ; Select FLASH
                                 .ORG        0x0000                      ; Start program memory at address 0x0000
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  STARTUP / RESET
                                 ; ------------------------------------------------------------------------------
                                 MAIN_000STARTUP:
000000 c014                              rjmp    MAIN_010INIT            ; Skip interrupt vectors
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  INTERRUPT VECTORS
                                 ; ------------------------------------------------------------------------------
                                 .ORG    INT0addr                        ; External interrupt request 0 (PD2)
000001 c085                              rjmp    sub_DECODER_INT0isr
                                 .ORG    OVF0addr                        ; Timer0/Counter0 overflow
000006 c06a                              rjmp    sub_DECODER_TIMER0isr
                                 .ORG    OVF1addr                        ; Timer1/Counter1 overflow
000005 c05b                              rjmp    sub_MAIN_TIMER1isr
                                 
                                 .ORG INT_VECTORS_SIZE                   ; Leave space to interrupt vectors
                                 
                                 ; ==============================================================================
                                 ;  MAIN PROGRAM
                                 ; ==============================================================================
                                 MAIN_010INIT:
                                     ; --------------------------------------------------------------------------
                                     ;  INITIALIZATION SEQUENCE
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Initialize STACK pointer
000015 ed0f                          ldi     rAccu, LOW(RAMEND)
000016 bf0d                          out     SPL, rAccu
                                     ;ldi     rAccu, HIGH(RAMEND)      ; For controllers >256kb RAM
                                     ;out     SPH, rAccu               ; For controllers >256kb RAM
                                 
                                     ; Initialize inputs - Carrera Manchester code.
000017 b301                          in      rAccu, ioCMCddr
000018 7000                          andi    rAccu, (0 << ioCMCsignal)
000019 bb01                          out     ioCMCddr, rAccu
                                 
                                     ; Initialize outputs - startlights.
00001a ef0f                          ser     rAccu
00001b bb07                          out     ioLEDddr, rAccu
00001c 2700                          clr     rAccu
00001d bb08                          out     ioLEDport, rAccu
                                 
                                     ; Initialize outputs - debug pins.
00001e b301                          in      rAccu, ioDEBUGddr
00001f 6600                          ori     rAccu, (1 << ioDEBUGred) | (1 << ioDEBUGyellow)
000020 bb01                          out     DDRD, rAccu
000021 9895                          cbi     ioDEBUGport, ioDEBUGred
000022 9896                          cbi     ioDEBUGport, ioDEBUGyellow
                                 
                                     ; Clear reserved SRAM.
000023 e21c
000024 e6e0
000025 e0f0
000026 2700
000027 9301
000028 951a
000029 2311
00002a f7e1                          mac_DECODER_SRAMclear
                                 
                                     ; Initialize and start TIMER1 to blink LEDs.
00002b e003
00002c bd0e
00002d e408
00002e bd0d
00002f ee05
000030 bd0c
000031 2488                          mac_MAIN_TIMER1init
000032 b709
000033 6800
000034 bf09                          mac_MAIN_TIMER1start
                                 
                                     ; Initialize and start TIMER0
                                     ; to count elapsed time between Carrera Manchester code edge changes.
000035 e001
000036 bf03
000037 ec03
000038 bf02                          mac_DECODER_TIMER0init
                                 
                                     ; Initialize and start external interrupt INT0
                                     ; to receive Carrera Manchester code edge changes.
000039 2422
00003a 2433
00003b 2444
00003c 2455
00003d b705
00003e 7f0d
00003f 6001
000040 bf05                          mac_DECODER_INT0init
000041 b70b
000042 6400
000043 bf0b                          mac_DECODER_INT0start
                                 
                                     ; Reset transfer register.
000044 2722                          clr     rTransfer
                                 
                                     ; Enable global interrupts.
000045 9478                          sei
                                 
                                 MAIN_021WAIT4DATA:
                                     ; --------------------------------------------------------------------------
                                     ;  WAIT FOR DATA
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Start Green-LED blinking
                                     ;ldi     rAccu, ((1<<ioLEDred1) | (1<<ioLEDred3) | (1<<ioLEDred5))
000046 e100                          ldi     rAccu, (1<<ioLEDred3)
000047 bb08                          out     ioLEDport, rAccu
                                     ;ldi     rAccu, ((1<<ioLEDred1) | (1<<ioLEDred2) | (1<<ioLEDred3) | (1<<ioLEDred4)| (1<<ioLEDred5))
000048 2e80                          mov     rBlinkMask, rAccu
000049 b709
00004a 6800
00004b bf09                          mac_MAIN_TIMER1start
                                 
                                 MAIN_021WAIT4DATA_10GetData:
                                     ; Check if TIMER0 interrupt has detected the completion of transmission.
00004c ff30                          sbrs    rDecoderState, flTransmComplete
00004d cffe                          rjmp    MAIN_021WAIT4DATA_10GetData
                                     ; Loop until there is a programm datapacket (= first datapacket) received.
                                     ; Only the programming datapacket has a length of 12Bits.
00004e e00c                          ldi     rAccu, flProgDpLength
00004f 1640                          cp      rReceivedBitCnt, rAccu
000050 f7d9                          brne    MAIN_021WAIT4DATA_10GetData
                                 MAIN_021WAIT4DATA_10GetData_Exit:
                                     ; Turn all LEDs off.
000051 2700                          clr     rAccu
000052 2e80                          mov     rBlinkMask, rAccu
000053 bb08                          out     ioLEDport, rAccu
                                     ; Initialize finite state machine.
000054 d0f0                          rcall   sub_FSM_00init
                                 MAIN_021WAIT4DATA_EXIT:
                                 
                                 MAIN_022LOOP:
                                     ; --------------------------------------------------------------------------
                                     ;  MAIN LOOP
                                     ; --------------------------------------------------------------------------
                                 
                                 MAIN_022LOOP_10GetData:
                                     ; Check if TIMER0 interrupt has detected the completion of transmission.
000055 ff30                          sbrs    rDecoderState, flTransmComplete
000056 c002                          rjmp    MAIN_022LOOP_10GetData_Exit
000057 7f3e                          cbr     rDecoderState, (1<<flTransmComplete)
000058 d05c                          rcall   sub_DECODER_SaveData                   ; Save data
                                 MAIN_022LOOP_10GetData_Exit:
                                 
                                 MAIN_022LOOP_20ProcessData:
                                     ; If a new datapacket is saved, check it.
000059 ff31                          sbrs    rDecoderState, flDataEvaluated
00005a c005                          rjmp    MAIN_022LOOP_20ProcessData_Exit
00005b 7f3d                          cbr     rDecoderState, (1<<flDataEvaluated)
00005c d081                          rcall   sub_DECODER_CheckData                   ; Evaluate data
                                     ; If data validation results are available, run State Machine.
00005d 2322                          tst     rTransfer
00005e f009                          breq    MAIN_022LOOP_20ProcessData_Exit
00005f d0ee                          rcall   sub_FSM_00Run                           ; Run finite state machine
                                 MAIN_022LOOP_20ProcessData_Exit:
                                 
                                     ; Back to main loop
000060 cff4                          rjmp    MAIN_022LOOP
                                 
                                 ; ==============================================================================
                                 ;  SUB PROGRAMS
                                 ; ==============================================================================
                                 
                                 sub_MAIN_TIMER1isr:
                                     ; --------------------------------------------------------------------------
                                     ;  TIMER1
                                     ;
                                     ;  The interrupt is triggered every 500ms and toggles the port pins defined
                                     ;  in the blink register (rBlinkMask).
                                     ; --------------------------------------------------------------------------
                                     ; Save SREG and registers to STACK.
000061 930f                          push    rAccu
000062 b70f                          in      rAccu, SREG
000063 930f                          push    rAccu
                                 
                                     ; Preload counter // timerclock 2Hz (500ms).
000064 e408                          ldi     rAccu, HIGH(cfgTIMER1_TCNT1)
000065 bd0d                          out     TCNT1H, rAccu
000066 ee05                          ldi     rAccu, LOW(cfgTIMER1_TCNT1)
000067 bd0c                          out     TCNT1L, rAccu
                                 
                                     ; Toggle LED based on den blink mask
000068 b308                          in      rAccu, ioLEDport
000069 2508                          eor     rAccu, rBlinkMask
00006a bb08                          out     ioLEDport, rAccu
                                 
                                         ; Turn off Debug LED
00006b 9895                          cbi     ioDEBUGport, ioDEBUGred
00006c 9896                          cbi     ioDEBUGport, ioDEBUGyellow
                                 
                                 sub_MAIN_TIMER1isr_Exit:
                                 
                                     ; Restore SREG and registers from STACK.
00006d 910f                          pop     rAccu
00006e bf0f                          out     SREG, rAccu
00006f 910f                          pop     rAccu
                                 
                                     ; All done! --> Return from interrupt.
000070 9518                          reti
                                 
                                 ; ------------------------------------------------------------------------------
                                 ;  INCLUDES - CODE
                                 ; ------------------------------------------------------------------------------
                                 .LIST
                                     .INCLUDE "decoder.asm"
                                 
                                 ;  INCLUDE TITLE   : Manchester Decoder for Carrera Digital 124/132
                                 ;  INCLUDE TYPE    : - DEKLARATIONS    X CODE
                                 ; ==============================================================================
                                 ;  FILE            : decoder.asm
                                 ;  MAIN TITLE      : Startampel "Bären(n)keller"
                                 ;  MAIN FILE       : main.asm + main.inc
                                 ;  SW-VERSION      : 1.0
                                 ;  SW-DATE         : 2024-01-17 (jjjj-mm-dd)
                                 ;  SW-AUTHOR       : Andreas Wahl - 73642 Welzheim - Germany
                                 ;                  : https://www.andreas-wahl.de
                                 ;  LICENSE         : GNU AFFERO GENERAL PUBLIC LICENSE
                                 ;                  : Version 3, 2007-11-19
                                 ;                  : https://www.gnu.org/licenses/
                                 ; ==============================================================================
                                 ;  REQUIREMENTS:
                                 ;
                                 ;  Include file:
                                 ;  - decoder.inc
                                 ;
                                 ;  Register:
                                 ;  - rAccu (>=R16)
                                 ;  - rScratch (>=R16)
                                 ;  - rTransfer (No new data=cleared, new data available=set)
                                 ;  - rTimeElapsedCnt(>=R16)
                                 ;  - rReceivedByteH:rReceivedByteL (>=R3+1:>=R3)
                                 ;  - rReceivedBitCnt (>=R3)
                                 ;  - rReceivedPacketCnt (>=R3)
                                 ;
                                 ;  SRAM:
                                 ;  - SRAM_DataPackets (44 Bytes)
                                 ;
                                 ;  I/O:
                                 ;  - PIND2 for external interrupt INT0
                                 ;    - ioCMCpin=PIND
                                 ;    - ioCMCsignal=PIND2
                                 ;    + ioCMCsignal=PIND2 configured as input
                                 ;
                                 ; ==============================================================================
                                 ;  DESCRIPTION:
                                 ;
                                 ;  The control unit (CU) of the carrera digital 124/132 racetrack communicates
                                 ;  with the slotcars, sensors and actuators in the manchester code.
                                 ;  This is modulated to the driving voltage. During transmission the driving
                                 ;  voltage is pulled to ground according to the manchester coding.
                                 ;
                                 ;  The clock rate is 100us (=10kHz). A new CU datapacket is sent every 7.5ms.
                                 ;  The complete protocol sequence takes 75ms.
                                 ;
                                 ;  The CU sends a total of the following 10 datapackets of different length
                                 ;  in the same order. Each datapacket has a start bit but no stop bit.
                                 ;
                                 ;  Datapacket table:
                                 ; ----------------
                                 ;
                                 ;       Nr. |  Length |  Label (datapacket)
                                 ;      ------------------------------------------
                                 ;       1   |     12  |  Prog data / CU data
                                 ;       2   |      9  |  Pace-/Ghostcar
                                 ;       3   | 7 or 8  |  Active- or acknowledge (*)
                                 ;       4   |      9  |  Controller0 (*)
                                 ;       5   |      9  |  Controller4 (*)
                                 ;       6   |      9  |  Controller1 (*)
                                 ;       7   |      9  |  Controller5 (*)
                                 ;       8   |      9  |  Controller2 (*)
                                 ;       9   |      7  |  Active (*)
                                 ;      10   |      9  |  Controller3 (*)
                                 ;      ------------------------------------------
                                 ;
                                 ;  After the CU has sent the datapackets marked with (*), the slotcars and
                                 ;  sensors can send data to the CU. For this purpose, after 2.304ms
                                 ;  according to the datapacket the CU pulling the driving voltage for 50us
                                 ;  to ground and is starting to receiving data.
                                 ;  The exact communication between sensors and CU is not discussed here.
                                 ;  When decoding, however, it should be noted that this communication also
                                 ;  triggers the external interrupt.
                                 ;
                                 ;  In this case we are only interested in the program- and ghostcar-datapacket.
                                 ;
                                 ;  Structure of program datapacket (12 Bits):
                                 ;  ---------------------------------------------
                                 ;
                                 ;      Bits (3)  9 - 11:   Controller (0-5: slotcar / 7: controll unit)
                                 ;      Bits (5)  4 -  8:   Instruction
                                 ;      Bits (4)  0 -  3:   Value
                                 ;
                                 ;      !! ATTENTION !!
                                 ;      The CU is sending the least significant bit (LSB) of the controller datapacket
                                 ;      first. Due to the left shift (lsl) in the following decoder routine
                                 ;      of the received bits, the bits are in reverse order in memory.
                                 ;
                                 ;      However, this is a big advantage because it results in a separation of the
                                 ;      <instruction> in the low byte and the <value> in the high byte.
                                 ;      If the MSB were sent first, the <instruction> would be separated in 2 bytes.
                                 ;
                                 ;  Instruction table:
                                 ;  ------------------
                                 ;
                                 ;      Ctrl. | Instr. | Val.  | Description
                                 ;      ------------------------------------------------------------------------
                                 ;       0-5  |    0   |  0-15 | Prog. velocity value <Val.> to slotcar <ctrl.>
                                 ;       0-5  |    1   |  0-15 | Program brake value <Val.> to slotcar <ctrl.>
                                 ;       0-5  |    2   |  0-15 | Program fuel maximum <Val.> to slotcar <ctrl.>
                                 ;       0-5  |    4   |     0 | Race - NO pitlane - no fuel consumption (=0)
                                 ;       0-5  |    4   |  0- 7 | Race - WITH pitlane - fuel remaining = <Val.>
                                 ;       0-5  |    4   |     8 | Early start of slotcar <controller>
                                 ;            |        |       |   - NO pitlane - no fuel consumption (=8)
                                 ;       0-5  |    4   |  8-15 | Early Start of slotcar <controller>
                                 ;            |        |       |   - WITH pitlane - fuel remaining = <val.>-8
                                 ;       0-7  |    5   |     0 | Slotcar <ctrl.> leaves refueling mode
                                 ;       0-7  |    5   |     1 | Slotcar <ctrl.> goes to the refueling mode
                                 ;       0-7  |    6   |  1- 8 | Position slotcar <ctrl.> is <val.>
                                 ;         0  |    6   |     9 | Reset position and lap counter
                                 ;       0-7  |    7   |     1 | Slotcar <ctrl.> finish the race
                                 ;       0-7  |    8   |     1 | Slotcar <ctrl.> finish lap with best time
                                 ;       0-7  |    9   |     1 | Slotcar <ctrl.> finish lap without best time
                                 ;       0-5  |   10   |  0- 7 | Fuel level <val.> of slotcar <ctrl.>
                                 ;         0  |   10   |    15 | Switch off fuel gauge on the drivers display
                                 ;         4  |   10   |    15 | Reset (first prog. data packet)
                                 ;       0-5  |   11   |     1 | Early start of slotcar <controller>
                                 ;         7  |   16   |  0- 5 | LEDs (0-5) on (control unit and start lights)
                                 ;         7  |   17   |  0-15 | High nibble of the lap counter of the leader
                                 ;         7  |   18   |  0-15 | Low nibble of the lap counter of the leader
                                 ;         7  |   19   |     0 | Reset
                                 ;         7  |   20   |  1- 4 | Pitlane/checkline mode <val.>
                                 ;            |        |       |   1=off, 2=finish line,
                                 ;            |        |       |   3=meantime 1, 4=meantime 2
                                 ;         7  |   20   |    15 | Check if pitlane is installed
                                 ;         7  |   21   |  0- 1 | Performance meassurement mode (<val.>
                                 ;            |        |       |   1=on, 2=off).
                                 ;      ------------------------------------------------------------------------
                                 ;
                                 ;  Structure of pacecar-datapacket (8 bits):
                                 ;  ---------------------------------------
                                 ;      Bit   6 - 8:   Controller (always 7: control unit)
                                 ;      Bit       5:   Track closed (1=closed, 0=open)
                                 ;      Bit       4:   Toggle
                                 ;      Bit       3:   Track open (1=open, 1=closed)
                                 ;      Bit       2:   Recall pacecar
                                 ;      Bit       1:   Pacecar active (1=active, 0=inactive)
                                 ;      Bit       0:   Fuel consumption active
                                 ;
                                 ;      !! ATTENTION !!
                                 ;      The CU is sending the most significant bit (MSB) of the pacecar
                                 ;      datapacket at first. This is contrary to the program datapacket!
                                 ;
                                 ; ==============================================================================
                                 ;
                                 ;   Further information to decode carrera manchester code:
                                 ;   - http://slotbaer.de/
                                 ;   - http://slotbaer.de/Carrera-digital-124-132/9-cu-daten-protokoll.html
                                 ;
                                 ;   General information about manchester coding with AVR microcontrollers:
                                 ;   - Atmel APPLICATION NOTE - Manchester Coding Basics
                                 ;   - https://ww1.microchip.com/downloads/en/Appnotes/Atmel-9164-Manchester-Coding-Basics_Application-Note.pdf
                                 ;
                                 ; ==============================================================================
                                 
                                 ; ==============================================================================
                                 ;  SUB PROGRAMS
                                 ; ==============================================================================
                                 
                                 sub_DECODER_TIMER0isr:
                                     ; --------------------------------------------------------------------------
                                     ;  TIMER0
                                     ;
                                     ;  The TIMER0 is triggered every 10us and increments a counter.
                                     ;  Within the ISR INT0, the elapsed time between the edge changes of the
                                     ;  carrera manchester code can be measured by reading the counter value.
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Save SREG and registers to STACK.
000071 930f                          push    rAccu
000072 b70f                          in      rAccu, SREG
000073 930f                          push    rAccu
                                 
                                     ; Stop external interrupt to avoid disturbing this interrupt.
000074 b70b
000075 7b0f
000076 bf0b                          mac_DECODER_INT0stop
                                 
                                     ; Preload counter for new interval.
000077 ec03                          ldi     rAccu, cfgTIMER0_TCNT0
000078 bf02                          out     TCNT0, rAccu
                                 
                                     ; Increment time elapsed counter.
                                     ; Counts every 10us --> Value 10 equals 100us (10kHz).
000079 9543                          inc     rTimeElapsedCnt
                                 
                                     ; If time elapsed >130us (> 5/4T [125us]),
                                     ; then last bit of datapacket is received.
                                     ; If condition occurs due to an overflow but no data is received,
                                     ; it can be detected by observing the length of the received bits.
00007a 304e                          cpi     rTimeElapsedCnt, 14
00007b f020                          brlo    DECODER_TIMER0isr_Exit
                                 
00007c 6031                          sbr     rDecoderState, (1<<flTransmComplete)    ; Inform that transmission
                                                                                     ; is completed. New datapacket
                                                                                     ; is available to check.
                                 
                                     ; End of frame. Stop time elapsed timer
00007d b709
00007e 7f0d
00007f bf09                          mac_DECODER_TIMER0stop
                                 
                                 DECODER_TIMER0isr_Exit:
                                     ; Restart stopped external interrupt.
000080 b70b
000081 6400
000082 bf0b                          mac_DECODER_INT0start
                                 
                                     ; Restore SREG and registers from STACK.
000083 910f                          pop     rAccu
000084 bf0f                          out     SREG, rAccu
000085 910f                          pop     rAccu
                                 
                                     ; All done! --> Return from interrupt
000086 9518                          reti
                                 
                                 sub_DECODER_INT0isr:
                                 ; ------------------------------------------------------------------------------
                                 ;  EXTERNAL INTERRUPT INT0
                                 ;
                                 ;  The interrupt is triggered every edge changes of the Carrera Manchester code.
                                 ;  Together with the counter from TIMER0, the Carrera Manchester code will be
                                 ;  decoded and the received bits are stored in two receive registers.
                                 ; ------------------------------------------------------------------------------
                                     ; Save SREG and registers to STACK.
000087 931f                          push    rScratch
000088 930f                          push    rAccu
000089 b70f                          in      rAccu, SREG
00008a 930f                          push    rAccu
                                 
                                     ; Prevent own call during processing.
00008b b70b
00008c 7b0f
00008d bf0b                          mac_DECODER_INT0stop
                                 
                                 
                                 DECODER_INT0isr_10CheckTimer:
                                     ; If timer is running then check time elapsed between the previous edge change.
                                     ; Else there may start a new data frame.
00008e b709                          in      rAccu, TIMSK                    ; Read current state
00008f fd01                          sbrc    rAccu, TOIE0                    ; If timer is running...
000090 c008                          rjmp    DECODER_INT0isr_11CheckNewBit   ; ... check for new bit.
                                 
                                     ; New data frame starts.
                                     ; Start timer to  measure the elapsed time between the edge changes.
                                     ;mac_DECODER_TIMER0init
000091 2744
000092 b709
000093 6002
000094 bf09                          mac_DECODER_TIMER0start
                                 
                                     ; Clear memory to receive new datapacket.
000095 2422                          clr     rReceivedByteL
000096 2433                          clr     rReceivedByteH
000097 2444                          clr     rReceivedBitCnt
                                 
                                     ; Exit Interrupt
000098 c004                          rjmp DECODER_INT0isr_19CheckExit
                                 
                                 DECODER_INT0isr_11CheckNewBit:
                                     ; Check if edge change is in the Carrera Manchester clock (10kHz).
                                     ; If time elapsed > 80us and < 120us then we are receiving a new bit.
                                 
                                 DECODER_INT0isr_12Check80us:
                                     ; Time elapsed >80us (> 3/4T [75us])?
                                     ; -> true: check next.
                                     ; -> false: nothing to do -> exit ISR.
000099 3048                          cpi      rTimeElapsedCnt, 8
00009a f010                          brlo    DECODER_INT0isr_19CheckExit
                                 
                                 DECODER_INT0isr_13Check120us:
                                     ; Time elapsed <120us (< 5/4T [125us])?
                                     ; -> true: get new bit.
                                     ; -> false: check next.
00009b 304c                          cpi      rTimeElapsedCnt, 12
00009c f008                          brlo    DECODER_INT0isr_20GetNewBit
                                 
                                 DECODER_INT0isr_19CheckExit:
                                     ; Nothing to do at this point --> exit ISR.
00009d c00f                          rjmp    DECODER_INT0isr_99Exit
                                 
                                 DECODER_INT0isr_20GetNewBit:
                                     ; Get new bit.
                                 
                                     ; Clear time elapsed counter to check next edge change.
00009e 2744                          clr     rTimeElapsedCnt
                                 
                                     ; Add received bit.
00009f 0c22                          lsl     rReceivedByteL
0000a0 1c33                          rol     rReceivedByteH
0000a1 e001                          ldi     rAccu, 0b00000001
0000a2 9b82                          sbis    ioCMCpin, ioCMCsignal
0000a3 2a20                          or      rReceivedByteL, rAccu
                                 
                                     ; Increment received bit counter.
0000a4 9443                          inc     rReceivedBitCnt
                                 
                                     ; * * * * * D E B U G * * * * *
                                     ; Send received Manchester clock * 2 (200us, 5kHz) to debug pin.
0000a5 e410                          ldi     rScratch, 1 << ioDEBUGyellow
0000a6 b302                          in      rAccu, ioDEBUGport
0000a7 2701                          eor     rAccu, rScratch
0000a8 bb02                          out     ioDEBUGport, rAccu
                                     ; * * * * * D E B U G * * * * *
                                 
                                     ; * * * * * D E B U G * * * * *
                                     ; Send received data to debug pin.
0000a9 9982                          sbic    ioCMCpin, ioCMCsignal
0000aa 9a95                          sbi     ioDEBUGport, ioDEBUGred
0000ab 9b82                          sbis    ioCMCpin, ioCMCsignal
0000ac 9895                          cbi     ioDEBUGport, ioDEBUGred
                                     ; * * * * * D E B U G * * * * *
                                 
                                 DECODER_INT0isr_99Exit:
                                     ; Restart stopped external interrupt INT0.
0000ad b70b
0000ae 6400
0000af bf0b                          mac_DECODER_INT0start
                                 
                                     ; Restore SREG and registers from STACK.
0000b0 910f                          pop     rAccu
0000b1 bf0f                          out     SREG, rAccu
0000b2 910f                          pop     rAccu
0000b3 911f                          pop     rScratch
                                 
                                     ; All done! --> Return from interrupt.
0000b4 9518                          reti
                                 
                                 sub_DECODER_SaveData:
                                 ; ------------------------------------------------------------------------------
                                 ;  SAVE NEW DATAPACKET
                                 ;
                                 ;  Check received datapacket and save it to SRAM.
                                 ; ------------------------------------------------------------------------------
                                     ; Save SREG and registers to STACK.
0000b5 93ef                          push    ZL
0000b6 93ff                          push    ZH
0000b7 931f                          push    rScratch
0000b8 930f                          push    rAccu
0000b9 b70f                          in      rAccu, SREG
0000ba 930f                          push    rAccu
                                 
                                     ; Clear data evaluated flag.
0000bb 7f3d                          cbr     rDecoderState, (1<<flDataEvaluated)
                                 
                                 DECODER_SaveData_11Check1:
                                     ; Check if a valid datapacket (minimum 7bit) was received.
0000bc 2d04                          mov     rAccu, rReceivedBitCnt
0000bd 5007                          subi    rAccu, 7
0000be f0a8                          brcs    DECODER_SaveData_19Exit
                                 
                                 DECODER_SaveData_12Check2:
                                     ; Check if it is a programm datapacket (= first datapacket).
                                     ; Only the programming datapacket has a length of 12Bits.
0000bf e00c                          ldi     rAccu, flProgDpLength
0000c0 1640                          cp      rReceivedBitCnt, rAccu
0000c1 f409                          brne    DECODER_SaveData_13Save
                                 
                                     ; Reset datapacket counter to first datapacket (=0).
0000c2 2455                          clr     rReceivedPacketCnt
                                 
                                 DECODER_SaveData_13Save:
                                     ; Save datapacket to SRAM.
                                 
                                     ; Set pointer to SRAM address.
0000c3 e6e0                          ldi     ZL, LOW (SRAM_DataPackets)
0000c4 e0f0                          ldi     ZH, HIGH (SRAM_DataPackets)
                                 
                                     ; Move pointer by datapacket counter.
0000c5 2d05                          mov     rAccu, rReceivedPacketCnt         ; For 4-byte data array...
0000c6 0f00                          lsl     rAccu                           ; ...multiply packet counter with 4
0000c7 0f00                          lsl     rAccu                           ; ...by shifting two times left
0000c8 0fe0                          add     ZL, rAccu                       ; Add datapacket offset to pointer
0000c9 2700                          clr     rAccu                           ; ...set rAccu to zero and
0000ca 1ff0                          adc     ZH, rAccu                       ; ...consider carryflag
                                 
                                     ; Save datapacket to SRAM.
0000cb 9251                          st      Z+, rReceivedPacketCnt
0000cc 9241                          st      Z+, rReceivedBitCnt
0000cd 9221                          st      Z+, rReceivedByteL
0000ce 8230                          st      Z, rReceivedByteH
                                 
                                     ; Set data evaluated flag to inform the main loop
                                     ; that there is new data in SRAM.
0000cf 6032                          sbr     rDecoderState, (1<<flDataEvaluated)
                                 
                                     ; If the packet counter unexpectedly reaches the value 11,
                                     ; then do not further count up. 10 datapackets are normal.
                                     ; 11 datapackets for debugging allowed.
                                     ; Reset occurs when program datapackets is recognized. See above.
0000d0 e00b                          ldi     rAccu, 11
0000d1 1640                          cp      rReceivedBitCnt, rAccu
0000d2 f009                          breq    DECODER_SaveData_19Exit
                                 
                                     ; Increment datapackets counter by 1.
0000d3 9453                          inc     rReceivedPacketCnt
                                 
                                 DECODER_SaveData_19Exit:
                                     ; Clear received bit counter (=0).
0000d4 2422                          clr     rReceivedByteL
0000d5 2433                          clr     rReceivedByteH
0000d6 2444                          clr     rReceivedBitCnt
                                 
                                     ; Restore SREG and registers from STACK.
0000d7 910f                          pop     rAccu
0000d8 bf0f                          out     SREG, rAccu
0000d9 910f                          pop     rAccu
0000da 911f                          pop     rScratch
0000db 91ff                          pop     ZH
0000dc 91ef                          pop     ZL
                                 
                                     ; All done! --> Return from interrupt.
0000dd 9518                          reti
                                 
                                 sub_DECODER_CheckData:
                                 ; ------------------------------------------------------------------------------
                                 ;  DATAPACKET CHECK ROUTINE
                                 ;
                                 ;  Check the received datapackets for relevant information, extract it and
                                 ;  return the results in the rTransfer register.
                                 ; ------------------------------------------------------------------------------
                                     ; Save SREG and registers from STACK.
0000de 93ef                          push    ZL
0000df 93ff                          push    ZH
0000e0 931f                          push    rScratch
0000e1 930f                          push    rAccu
0000e2 b70f                          in      rAccu, SREG
0000e3 930f                          push    rAccu
                                 
                                     ; Set pointer to received datapacket.
0000e4 e6e0                          ldi     ZL, LOW (SRAM_DataPackets)
0000e5 e0f0                          ldi     ZH, HIGH (SRAM_DataPackets)
                                 
                                     ; Clear transfer register for new results.
0000e6 2722                          clr     rTransfer
                                 
                                     ; Check if saved program datapacket has the correct length.
0000e7 8101                          ldd     rAccu, Z + (pStartProgCU + pOffsetDpCnt)
0000e8 300c                          cpi     rAccu, flProgDpLength
0000e9 f009                          breq    DECODER_CheckData_10Reset
0000ea c044                          rjmp    DECODER_CheckData_50PaceCar
                                 
                                 DECODER_CheckData_10Reset:
                                     ; --------------------------------------------------------------------------
                                     ; Check for reset.
                                     ; Reset 1: Controller=7, instruction=19, value=0.
                                     ; --------------------------------------------------------------------------
                                 DECODER_CheckData_11Reset1:
                                     ; Check if reset 1 - condition 1.
0000eb 8102                          ldd     rAccu, Z + (pStartProgCU + pOffsetDpLow)
0000ec 3c0f                          cpi     rAccu, 0b11001111            ; Instruction=19 and controller=7?
0000ed f439                          brne    DECODER_CheckData_19Reset_Exit
                                 
                                     ; Check if reset 1 - condition 2.
0000ee 8103                          ldd     rAccu, Z + (pStartProgCU + pOffsetDpHigh)
0000ef 700f                          andi    rAccu, 0b00001111            ; Check value
0000f0 2300                          tst     rAccu                        ; value=0?
0000f1 f419                          brne    DECODER_CheckData_19Reset_Exit
                                 
                                     ; Set reset flag.
0000f2 6820                          sbr     rTransfer, (1<<flProgReset)
                                 
                                     ; Set Debug LED
0000f3 9a95                          sbi     ioDEBUGport, ioDEBUGred
                                 
                                     ; Check with results -> exit CheckData.
0000f4 c049                          rjmp    DECODER_CheckData_99Exit
                                 
                                 DECODER_CheckData_19Reset_Exit:
                                 
                                 DECODER_CheckData_20StartLight:
                                     ; --------------------------------------------------------------------------
                                     ; Check for start lights
                                     ; Instruction = 16, value=<LED>, controller=7.
                                     ; --------------------------------------------------------------------------
                                     ; Load and check controller and instruction.
0000f5 8102                          ldd     rAccu, Z + (pStartProgCU + pOffsetDpLow)
0000f6 300f                          cpi     rAccu, 0b00001111               ; Controller=7, instruction=16
0000f7 f479                          brne    DECODER_CheckData_29StartLight_Exit
                                 
                                     ; Load values.
0000f8 8113                          ldd     rScratch, Z + (pStartProgCU + pOffsetDpHigh)
0000f9 701f                          andi    rScratch, 0x0F                  ; Filter start light value
                                 
                                     ; Rotate value bits. LSB -> MSB
0000fa 2700                          clr     rAccu
0000fb 9517                          ror     rScratch                        ; Bit 3
0000fc 1f00                          rol     rAccu
0000fd 9517                          ror     rScratch                        ; Bit 2
0000fe 1f00                          rol     rAccu
0000ff 9517                          ror     rScratch                        ; Bit 1
000100 1f00                          rol     rAccu
000101 9517                          ror     rScratch                        ; Bit 0
000102 1f00                          rol     rAccu
                                 
                                     ; Shrink value.
000103 7007                          andi    rAccu, mskProgValues
                                 
                                     ; Set start light flag.
000104 6100                          sbr     rAccu, (1<<flProgStartLights)
                                 
                                     ; Copy the results into the transfer register.
000105 2f20                          mov     rTransfer, rAccu
                                 
                                     ; Check with results -> exit CheckData.
000106 c037                          rjmp    DECODER_CheckData_99Exit
                                 
                                 DECODER_CheckData_29StartLight_Exit:
                                 
                                 DECODER_CheckData_30RaceFinished:
                                     ; --------------------------------------------------------------------------
                                     ; Check if race has been finished.
                                     ; Instruction = 7, value=1, controller=<No. slotcar that wins the race>.
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Load datapacket and check instruction.
000107 8102                          ldd     rAccu, Z + (pStartProgCU + pOffsetDpLow)
000108 2f10                          mov     rScratch, rAccu                 ; Save for later use
000109 7f08                          andi    rAccu, 0b11111000               ; Mask instruction bits
00010a 3e00                          cpi     rAccu, 0b11100000               ; Check if race finished
00010b f479                          brne    DECODER_CheckData_39RaceFinished_Exit
                                 
                                     ; Load prog. datapacket and check value as a second condition.
00010c 8103                          ldd     rAccu, Z + (pStartProgCU + pOffsetDpHigh)
00010d 700f                          andi    rAccu, 0b00001111               ; Mask value bits
00010e 3008                          cpi     rAccu, 0b00001000               ; Check if value=1
00010f f459                          brne    DECODER_CheckData_39RaceFinished_Exit
                                 
                                     ; Rotate controller bits. LSB -> MSB
000110 2700                          clr     rAccu
000111 9517                          ror     rScratch                        ; Bit 2
000112 1f00                          rol     rAccu
000113 9517                          ror     rScratch                        ; Bit 1
000114 1f00                          rol     rAccu
000115 9517                          ror     rScratch                        ; Bit 0
000116 1f00                          rol     rAccu
                                 
                                     ; Shrink value.
000117 7007                          andi    rAccu, mskProgValues
                                 
                                     ; Set early start flag.
000118 6008                          sbr     rAccu, (1<<flProgFinished)
                                 
                                     ; Copy the results into the transfer register.
000119 2f20                          mov     rTransfer, rAccu
                                 
                                     ; Check with results -> exit CheckData.
00011a c023                          rjmp    DECODER_CheckData_99Exit
                                 
                                 DECODER_CheckData_39RaceFinished_Exit:
                                 
                                 DECODER_CheckData_40EarlyStart:
                                     ; --------------------------------------------------------------------------
                                     ; Check for early start.
                                     ; Instruction = 11, value=1, controller=<No. slotcar done a early start>.
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Load datapacket and check instruction.
00011b 8102                          ldd     rAccu, Z + (pStartProgCU + pOffsetDpLow)
00011c 2f10                          mov     rScratch, rAccu                 ; Save for later use
00011d 7f08                          andi    rAccu, 0b11111000               ; Mask instruction bits
00011e 3d00                          cpi     rAccu, 0b11010000               ; Check if its early start (11)
00011f f479                          brne    DECODER_CheckData_49EarlyStart_Exit
                                 
                                     ; Load prog. datapacket and check value as a second condition.
000120 8103                          ldd     rAccu, Z + (pStartProgCU + pOffsetDpHigh)
000121 700f                          andi    rAccu, 0b00001111               ; Mask value bits
000122 3008                          cpi     rAccu, 0b00001000               ; Check if value=1
000123 f459                          brne    DECODER_CheckData_49EarlyStart_Exit
                                 
                                     ; Rotate controller bits. LSB --> MSB.
000124 2700                          clr     rAccu
000125 9517                          ror     rScratch                        ; Bit 2
000126 1f00                          rol     rAccu
000127 9517                          ror     rScratch                        ; Bit 1
000128 1f00                          rol     rAccu
000129 9517                          ror     rScratch                        ; Bit 0
00012a 1f00                          rol     rAccu
                                 
                                     ; Shrink value.
00012b 7007                          andi    rAccu, mskProgValues
                                 
                                     ; Set early start flag.
00012c 6200                          sbr     rAccu, (1<<flProgEarlyStart)
                                 
                                     ; Copy the results into the transfer register.
00012d 2f20                          mov     rTransfer, rAccu
                                 
                                     ; Check with results -> exit CheckData.
00012e c00f                          rjmp    DECODER_CheckData_99Exit
                                 
                                 DECODER_CheckData_49EarlyStart_Exit:
                                 
                                 DECODER_CheckData_50PaceCar:
                                     ; --------------------------------------------------------------------------
                                     ; Check pacecar.
                                     ; Following bits are set in PaceGhostCar-datapacket: 0b1|11xxxx1x.
                                     ; --------------------------------------------------------------------------
                                     ; Check if saved pacecar datapacket has the correct length.
00012f 8105                          ldd     rAccu, Z + (pStartPGC + pOffsetDpCnt)
000130 3009                          cpi     rAccu, flPgcDpLength
000131 f461                          brne    DECODER_CheckData_59PaceCar_Exit
                                 
                                     ; Load pace car datapacket and check instruction.
000132 8106                          ldd     rAccu, Z + (pStartPGC + pOffsetDpLow)
000133 8117                          ldd     rScratch, Z + (pStartPGC + pOffsetDpHigh)
                                 
                                     ; Shift all bits one position to left (no attention to fuel indicator).
000134 9516                          lsr     rScratch
000135 9507                          ror     rAccu
                                 
                                     ; Check if pace/ghostcar instruction.
000136 2f10                          mov     rScratch, rAccu                 ; Save datapacket for later use
000137 7e10                          andi    rScratch, 0b11100000            ; Mask pacecar instruction
000138 3e10                          cpi     rScratch, 0b11100000            ; Check instruction
000139 f421                          brne    DECODER_CheckData_59PaceCar_Exit
                                 
                                     ; Get pacecar values.
00013a 7003                          andi    rAccu, 0b00000011               ; Mask pacecar value bits
                                 
                                     ; Set pacecar flag.
00013b 6400                          sbr     rAccu, (1<<flProgPaceCar)
                                 
                                     ; Copy the results into the transfer register.
00013c 2f20                          mov     rTransfer, rAccu
                                 
                                     ; Check with results -> exit CheckData.
00013d c000                          rjmp    DECODER_CheckData_99Exit
                                 
                                 DECODER_CheckData_59PaceCar_Exit:
                                 
                                 DECODER_CheckData_99Exit:
                                     ; Restore SREG and registers from STACK.
00013e 910f                          pop     rAccu
00013f bf0f                          out     SREG, rAccu
000140 910f                          pop     rAccu
000141 911f                          pop     rScratch
000142 91ff                          pop     ZH
000143 91ef                          pop     ZL
                                 
                                     ; All done! --> Return from interrupt.
000144 9508                          ret
                                     .INCLUDE "fsm.asm"
                                 
                                 ;  INCLUDE TITLE   : Finite State Machine (FSM)
                                 ;  INCLUDE TYPE    : - DEKLARATIONS    X CODE
                                 ;  FILE            : fsm.asm
                                 ;  MAIN TITLE      : Startampel "Bären(n)keller"
                                 ;  MAIN FILE       : main.asm + main.inc
                                 ;  SW-VERSION      : 1.0
                                 ;  SW-DATE         : 2024-01-17 (jjjj-mm-dd)
                                 ;  SW-AUTHOR       : Andreas Wahl - 73642 Welzheim - Germany
                                 ;                  : https://www.andreas-wahl.de
                                 ;  LICENSE         : GNU AFFERO GENERAL PUBLIC LICENSE
                                 ;                  : Version 3, 2007-11-19
                                 ;                  : https://www.gnu.org/licenses/
                                 ; ==============================================================================
                                 ;  REQUIREMENTS:
                                 ;
                                 ;  Include file:
                                 ;  - fsm.inc
                                 ;
                                 ;  Register:
                                 ;  - rAccu (>=R16)
                                 ;  - rScratch (>=R16)
                                 ;  - rTransfer (>=R16)
                                 ;  - rBlinkMask
                                 ;  - rFsmCurrentState
                                 ;  - rFsmNextState
                                 ;
                                 ;  I/O - Output configuration for startlights:
                                 ;  - ioLEDport
                                 ;  - ioLEDred1, ioLEDred2, ioLEDred3, ioLEDred4, ioLEDred5
                                 ;  - ioLEDgreen
                                 ;  - ioLEDyellow
                                 ;  - ioEarlyStart1st
                                 ;  - ioEarlyStart1st (Start pin/bit to display slotcar with early start)
                                 ;  - ioEarlyStartDir (Slotcar number rotation [0=right, 1=left])
                                 ;
                                 ; ==============================================================================
                                 ;  DESCRIPTION:
                                 ;
                                 ;  The state of the startlights follow defined steps.
                                 ;  Moving from one step to the next depends on fixed conditions.
                                 ;  Therefore, the code is designed in the form of a finite state machine (FSM).
                                 ;
                                 ;  The following state of the startlights are defined:
                                 ;
                                 ;      State  0 - Init-Training         --> Green LED row = on
                                 ;      State  1 - Countdown 1           --> 1. Red LED column = on
                                 ;      State  2 - Countdown 2           --> 1.-2. Red LED column = on
                                 ;      State  3 - Countdown 3           --> 1.-3. Red LED column = on
                                 ;      State  4 - Countdown 4           --> 1.-4. Red LED column = on
                                 ;      State  5 - Countdown 5           --> All red LED columns = on
                                 ;      State  6 - Race                  --> Green LED row = on
                                 ;      State  7 - PaceCar               --> Yellow LED row = blinking
                                 ;      State  8 - EarlyStart            --> Yellow LED = on,
                                 ;                                           Red LED column (slotcar) = blinking
                                 ;      State  9 - Finished              --> Green LED = blinking,
                                 ;                                           Red LED column (slotcar) = on
                                 ;      State 10 - Chaos                 --> All red LED = blinking,
                                 ;      --- Above not specified LEDs are off ---
                                 ;
                                 ;  State table:
                                 ;  ------------
                                 ;
                                 ;       Current State | Exit Event                    | Next State     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State0Init    | Race (CU all LED off)         | State6Grn      |
                                 ;                     | Countdown 5 (CU 5 LED on)     | State5Red5     |
                                 ;                     | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State1Red1    | Countdown 2 (CU 2 LED on)     | State2Red2     |
                                 ;                     | Countdown 5 (CU 5 LED on)     | State5Red5     |
                                 ;                     | Early start detected          | State8Yel2     |
                                 ;                     | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State2Red2    | Countdown 3 (CU 3 LED on)     | State3Red3     |
                                 ;                     | Countdown 5 (CU 5 LED on)     | State5Red5     |
                                 ;                     | Early start detected          | State8Yel2     |
                                 ;                     | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State3Red3    | Countdown 4 (CU 4 LED on)     | State4Red4     |
                                 ;                     | Countdown 5 (CU 5 LED on)     | State5Red5     |
                                 ;                     | Early start detected          | State8Yel2     |
                                 ;                     | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State4Red4    | Countdown 5 (CU 5 LED on)     | State5Red5     |
                                 ;                     | Early start detected          | State8Yel2     |
                                 ;                     | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State5Red5    | Race (CU all LED off)         | State0Race     |
                                 ;                     | Countdown 1 (CU 1 LED on)     | State1Red1     |
                                 ;                     | Early start detected          | State8Yel2     |
                                 ;                     | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State6Grn     | Countdown 5 (CU 5 LED on)     | State5Red5     |
                                 ;                     | Chaos (CU 5 LED on & RACE)    | State10Chaos   |
                                 ;                     | Early start detected          | State8Yel2     |
                                 ;                     | Pacecar active                | State8Yel1     |
                                 ;                     | Race finished                 | State9RFin     |
                                 ;                     | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State7Yel1    | Pacecar inactive              | State6Grn      |
                                 ;       (PaceCar)     | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State8Yel2    | Countdown (CU 5 LED on)       | State1Red5     |
                                 ;       (EarlyStart)  | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State9RFin    | Countdown (CU 5 LED on)       | State1Red5     |
                                 ;       (R. Finished) | Reset detected                | State0Init     |
                                 ;      ---------------+-------------------------------+----------------|
                                 ;       State10Chaos  | Race (CU all LED off)         | State0Race     |
                                 ;                     | Countdown 1 (CU 1 LED on)     | State1Red1     |
                                 ;                     | Reset detected                | State0Init     |
                                 ;      -----------------------------------------------------------------
                                 ; ==============================================================================
                                 
                                 sub_FSM_00init:
                                     ; --------------------------------------------------------------------------
                                     ;  FINITE STATE MACHINE (FSM) - INIT
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Save SREG and registers to STACK.
000145 93ef                          push    ZL
000146 93ff                          push    ZH
000147 931f                          push    rScratch
000148 930f                          push    rAccu
000149 b70f                          in      rAccu, SREG
00014a 930f                          push    rAccu
                                 
                                     ; Prepare registers.
00014b e000                          ldi     rAccu, fsmState0Init
00014c 2e70                          mov     rFsmNextState, rAccu            ; Set Init-State
                                 
                                     ; Change State
00014d c186                          rjmp    FSM_98ChangeState
                                 
                                 sub_FSM_00run:
                                     ; --------------------------------------------------------------------------
                                     ;  FINITE STATE MACHINE (FSM) - RUN
                                     ; --------------------------------------------------------------------------
                                 
                                     ; Save SREG and registers to STACK.
00014e 93ef                          push    ZL
00014f 93ff                          push    ZH
000150 931f                          push    rScratch
000151 930f                          push    rAccu
000152 b70f                          in      rAccu, SREG
000153 930f                          push    rAccu
                                 
                                     ; Prepare registers.
000154 2c76                          mov     rFsmNextState, rFsmCurrentState ; Set next state to current state
000155 2711                          clr     rScratch                        ; Clear for use as pointer offset
                                 
                                     ; Jump to current state.
000156 e0f2                          ldi     ZH, HIGH (FSM_adrStateRun)      ; Load jumptable address...
000157 eeec                          ldi     ZL, LOW (FSM_adrStateRun)       ; ...to pointer.
000158 0de6                          add     ZL, rFsmCurrentState            ; Add state offset
000159 2700                          clr     rAccu
00015a 1ff0                          adc     ZH, rAccu                       ; Consider carryflag
                                 
00015b 9409                          ijmp                                    ; Jump to current state
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 0 - init-state - waiting for CU data.
                                     ; --------------------------------------------------------------------------
                                 FSM_10State0Init_0Entry:
                                     ; Set new state.
00015c e000                          ldi     rAccu,  fsmState0Init
00015d 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Clear Racing State
00015e 2755                          clr     rFsmRacing
                                     ; Out startlights.
00015f e002                          ldi     rAccu, (1<<ioLEDgreen)
000160 bb08                          out     ioLEDport, rAccu
                                 
                                 FSM_10State0Init_1Run:
                                     ; Check exit conditions.
000161 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_10State0Init_1Run_1:
                                     ; Check if countdown 0 - race - track open.
000162 ff24                          sbrs    rTransfer, flProgStartLights
000163 c008                          rjmp    FSM_10State0Init_1Run_3
000164 2f02                          mov     rAccu, rTransfer
000165 7007                          andi    rAccu, mskProgValues            ; Mask values
000166 3000                          cpi     rAccu, 0x00                     ; All LED off
000167 f409                          brne    FSM_10State0Init_1Run_2
000168 e016                          ldi     rScratch, fsmState6Grn
                                 
                                 FSM_10State0Init_1Run_2:
                                     ; Check if countdown 5 - prepare start / track closed / chaos.
000169 3005                          cpi     rAccu, 0x05                     ; 5 LED on
00016a f409                          brne    FSM_10State0Init_1Run_3
00016b e015                          ldi     rScratch, fsmState5Red5
                                 
                                 FSM_10State0Init_1Run_3:
                                     ; Check if pacecar.
00016c ff26                          sbrs    rTransfer, flProgPaceCar
00016d c005                          rjmp    FSM_10State0Init_1Run_4
00016e 2f02                          mov     rAccu, rTransfer
00016f 7001                          andi    rAccu, 0x01                     ; Mask pacecar bit
000170 3001                          cpi     rAccu, 0x01                     ; Check pacecar
000171 f409                          brne    FSM_10State0Init_1Run_4
000172 e017                          ldi     rScratch, fsmState7Yel1
                                 
                                 FSM_10State0Init_1Run_4:
                                     ; Check if reset.
000173 fd27                          sbrc    rTransfer, flProgReset
000174 e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_10State0Init_1Run_9:
                                     ; If a new state is set, exit the current state.
000175 2e71                          mov     rFsmNextState, rScratch
000176 1467                          cp      rFsmCurrentState, rFsmNextState
000177 f409                          brne    FSM_10State0Init_9Exit
000178 c161                          rjmp    FSM_99Exit
                                 
                                 FSM_10State0Init_9Exit:
                                     ; Out startlights.
000179 e002                          ldi     rAccu, (1<<ioLEDgreen)
00017a 9500                          com     rAccu
00017b 2280                          and     rBlinkMask, rAccu
00017c 98c1                          cbi     ioLEDport, ioLEDgreen
                                     ; Jump to new state entry.
00017d c156                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 1 - Countdown 1.
                                     ; --------------------------------------------------------------------------
                                 FSM_11State1Red1_0Entry:
                                     ; Set new state.
00017e e001                          ldi     rAccu, fsmState1Red1
00017f 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
000180 e400                          ldi     rAccu, (1<<ioLEDred1)
000181 bb08                          out     ioLEDport, rAccu
                                     ; Set Racing State
000182 e051                          ldi     rFsmRacing, 0x01
                                 
                                 FSM_11State1Red1_1Run:
                                     ; Check exit conditions.
000183 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_11State1Red1_1Run_1:
                                     ; Check if countdown 2.
000184 ff24                          sbrs    rTransfer, flProgStartLights
000185 c008                          rjmp    FSM_11State1Red1_1Run_3
000186 2f02                          mov     rAccu, rTransfer
000187 7007                          andi    rAccu, mskProgValues            ; Mask values
000188 3002                          cpi     rAccu, 0x02                     ; 2 LED on
000189 f409                          brne    FSM_11State1Red1_1Run_2
00018a e012                          ldi     rScratch, fsmState2Red2
                                 
                                 FSM_11State1Red1_1Run_2:
                                     ; Check if countdown 5 - (re-)start.
00018b 3005                          cpi     rAccu, 0x05                     ; 5 LED on
00018c f409                          brne    FSM_11State1Red1_1Run_3
00018d e015                          ldi     rScratch, fsmState5Red5
                                 
                                 FSM_11State1Red1_1Run_3:
                                     ; Check if early start.
00018e fd25                          sbrc    rTransfer, flProgEarlyStart
00018f e018                          ldi     rScratch, fsmState8Yel2
                                 
                                 FSM_11State1Red1_1Run_4:
                                     ; Check if reset.
000190 fd27                          sbrc    rTransfer, flProgReset
000191 e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_11State1Red1_1Run_9:
                                     ; If a new state is set, exit the current state.
000192 2e71                          mov     rFsmNextState, rScratch
000193 1467                          cp      rFsmCurrentState, rFsmNextState
000194 f409                          brne    FSM_11State1Red1_9Exit
000195 c144                          rjmp    FSM_99Exit
                                 
                                 FSM_11State1Red1_9Exit:
                                     ; Out startlights.
000196 2700                          clr     rAccu
000197 bb08                          out     ioLEDport, rAccu
                                     ; Jump to new state entry.
000198 c13b                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 2 - Countdown 2.
                                     ; --------------------------------------------------------------------------
                                 FSM_12State2Red2_0Entry:
                                     ; Set new state.
000199 e002                          ldi     rAccu, fsmState2Red2
00019a 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
00019b e600                          ldi     rAccu, (1<<ioLEDred1) | (1<<ioLEDred2)
00019c bb08                          out     ioLEDport, rAccu
                                     ; Update Racing State
00019d 0f55                          lsl     rFsmRacing
                                 
                                 FSM_12State2Red2_1Run:
                                     ; Check exit conditions.
00019e 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_12State2Red2_1Run_1:
                                     ; Check if countdown 3.
00019f ff24                          sbrs    rTransfer, flProgStartLights
0001a0 c008                          rjmp    FSM_12State2Red2_1Run_3
0001a1 2f02                          mov     rAccu, rTransfer
0001a2 7007                          andi    rAccu, mskProgValues            ; Mask values
0001a3 3003                          cpi     rAccu, 0x03                     ; 3 LED on
0001a4 f409                          brne    FSM_12State2Red2_1Run_2
0001a5 e013                          ldi     rScratch, fsmState3Red3
                                 
                                 FSM_12State2Red2_1Run_2:
                                     ; Check if countdown 5 - (re-)start.
0001a6 3005                          cpi     rAccu, 0x05                     ; 5 LED on
0001a7 f409                          brne    FSM_12State2Red2_1Run_3
0001a8 e015                          ldi     rScratch, fsmState5Red5
                                 
                                 FSM_12State2Red2_1Run_3:
                                     ; Check if early start.
0001a9 fd25                          sbrc    rTransfer, flProgEarlyStart
0001aa e018                          ldi     rScratch, fsmState8Yel2
                                 
                                 FSM_12State2Red2_1Run_4:
                                     ; Check if reset.
0001ab fd27                          sbrc    rTransfer, flProgReset
0001ac e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_12State2Red2_1Run_9:
                                     ; If a new state is set, exit the current state.
0001ad 2e71                          mov     rFsmNextState, rScratch
0001ae 1467                          cp      rFsmCurrentState, rFsmNextState
0001af f409                          brne    FSM_12State2Red2_9Exit
0001b0 c129                          rjmp    FSM_99Exit
                                 
                                 FSM_12State2Red2_9Exit:
                                     ; Out startlights.
0001b1 2700                          clr     rAccu
0001b2 bb08                          out     ioLEDport, rAccu
                                     ; Jump to new state entry.
0001b3 c120                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 3 - Countdown 3.
                                     ; --------------------------------------------------------------------------
                                 FSM_13State3Red3_0Entry:
                                     ; Set new state.
0001b4 e003                          ldi     rAccu, fsmState3Red3
0001b5 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
0001b6 e700                          ldi     rAccu, (1<<ioLEDred1) | (1<<ioLEDred2) | (1<<ioLEDred3)
0001b7 bb08                          out     ioLEDport, rAccu
                                     ; Update Racing State
0001b8 0f55                          lsl     rFsmRacing
                                 
                                 FSM_13State3Red3_1Run:
                                     ; Check exit conditions.
0001b9 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_13State3Red3_1Run_1:
                                     ; Check if countdown 4.
0001ba ff24                          sbrs    rTransfer, flProgStartLights
0001bb c008                          rjmp    FSM_13State3Red3_1Run_3
0001bc 2f02                          mov     rAccu, rTransfer
0001bd 7007                          andi    rAccu, mskProgValues            ; Mask values
0001be 3004                          cpi     rAccu, 0x04                     ; 4 LED on
0001bf f409                          brne    FSM_13State3Red3_1Run_2
0001c0 e014                          ldi     rScratch, fsmState4Red4
                                 
                                 FSM_13State3Red3_1Run_2:
                                     ; Check if countdown 5 - (re-)start.
0001c1 3005                          cpi     rAccu, 0x05                     ; 5 LED on
0001c2 f409                          brne    FSM_13State3Red3_1Run_3
0001c3 e015                          ldi     rScratch, fsmState5Red5
                                 
                                 FSM_13State3Red3_1Run_3:
                                     ; Check if early start.
0001c4 fd25                          sbrc    rTransfer, flProgEarlyStart
0001c5 e018                          ldi     rScratch, fsmState8Yel2
                                 
                                 FSM_13State3Red3_1Run_4:
                                     ; Check if reset.
0001c6 fd27                          sbrc    rTransfer, flProgReset
0001c7 e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_13State3Red3_1Run_9:
                                     ; If a new state is set, exit the current state.
0001c8 2e71                          mov     rFsmNextState, rScratch
0001c9 1467                          cp      rFsmCurrentState, rFsmNextState
0001ca f409                          brne    FSM_13State3Red3_9Exit
0001cb c10e                          rjmp    FSM_99Exit
                                 
                                 FSM_13State3Red3_9Exit:
                                     ; Out startlights.
0001cc 2700                          clr     rAccu
0001cd bb08                          out     ioLEDport, rAccu
                                     ; Jump to new state entry.
0001ce c105                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 4 - Countdown 4.
                                     ; --------------------------------------------------------------------------
                                 FSM_14State4Red4_0Entry:
                                     ; Set new state.
0001cf e004                          ldi     rAccu, fsmState4Red4
0001d0 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
0001d1 e708                          ldi     rAccu, (1<<ioLEDred1) | (1<<ioLEDred2) | (1<<ioLEDred3) | (1<<ioLEDred4)
0001d2 bb08                          out     ioLEDport, rAccu
                                     ; Update Racing State
0001d3 0f55                          lsl     rFsmRacing
                                 
                                 FSM_14State4Red4_1Run:
                                     ; Check exit conditions.
0001d4 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_14State4Red4_1Run_1:
                                     ; Check if countdown 5.
0001d5 ff24                          sbrs    rTransfer, flProgStartLights
0001d6 c005                          rjmp    FSM_14State4Red4_1Run_2
0001d7 2f02                          mov     rAccu, rTransfer
0001d8 7007                          andi    rAccu, mskProgValues            ; Mask values
0001d9 3005                          cpi     rAccu, 0x05                     ; 5 LED on
0001da f409                          brne    FSM_14State4Red4_1Run_2
0001db e015                          ldi     rScratch, fsmState5Red5
                                 
                                 FSM_14State4Red4_1Run_2:
                                     ; Check if early start.
0001dc fd25                          sbrc    rTransfer, flProgEarlyStart
0001dd e018                          ldi     rScratch, fsmState8Yel2
                                 
                                 FSM_14State4Red4_1Run_3:
                                     ; Check if reset.
0001de fd27                          sbrc    rTransfer, flProgReset
0001df e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_14State4Red4_1Run_9:
                                     ; If a new state is set, exit the current state.
0001e0 2e71                          mov     rFsmNextState, rScratch
0001e1 1467                          cp      rFsmCurrentState, rFsmNextState
0001e2 f409                          brne    FSM_14State4Red4_9Exit
0001e3 c0f6                          rjmp    FSM_99Exit
                                 
                                 FSM_14State4Red4_9Exit:
                                     ; Out startlights.
0001e4 2700                          clr     rAccu
0001e5 bb08                          out     ioLEDport, rAccu
                                     ; Jump to new state entry.
0001e6 c0ed                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 5 - Countdown 5.
                                     ; --------------------------------------------------------------------------
                                 FSM_15State5Red5_0Entry:
                                     ; Set new state.
0001e7 e005                          ldi     rAccu, fsmState5Red5
0001e8 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
0001e9 e70c                          ldi     rAccu, (1<<ioLEDred1) | (1<<ioLEDred2) | (1<<ioLEDred3) | (1<<ioLEDred4) | (1<<ioLEDred5)
0001ea bb08                          out     ioLEDport, rAccu
                                     ; Update Racing State
0001eb 0f55                          lsl     rFsmRacing
                                 
                                 FSM_15State5Red5_1Run:
                                     ; Check exit conditions.
0001ec 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_15State5Red5_1Run_1:
                                     ; Check if countdown 0 - Race - Track open.
0001ed ff24                          sbrs    rTransfer, flProgStartLights
0001ee c009                          rjmp    FSM_15State5Red5_1Run_3
0001ef 2f02                          mov     rAccu, rTransfer
0001f0 7007                          andi    rAccu, mskProgValues            ; Mask values
0001f1 3000                          cpi     rAccu, 0x00                     ; All LED off
0001f2 f411                          brne    FSM_15State5Red5_1Run_2
0001f3 e016                          ldi     rScratch, fsmState6Grn
0001f4 c003                          rjmp    FSM_15State5Red5_1Run_3
                                 
                                 FSM_15State5Red5_1Run_2:
                                     ; Check if countdown 1 - start countdown.
0001f5 3001                          cpi     rAccu, 0x01                     ; 1 LED on
0001f6 f409                          brne    FSM_15State5Red5_1Run_3
0001f7 e011                          ldi     rScratch, fsmState1Red1
                                 
                                 FSM_15State5Red5_1Run_3:
                                     ; Check if early start.
0001f8 fd25                          sbrc    rTransfer, flProgEarlyStart
0001f9 e018                          ldi     rScratch, fsmState8Yel2
                                 
                                 FSM_15State5Red5_1Run_4:
                                     ; Check if reset.
0001fa fd27                          sbrc    rTransfer, flProgReset
0001fb e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_15State5Red5_1Run_9:
                                     ; If a new state is set, exit the current state.
0001fc 2e71                          mov     rFsmNextState, rScratch
0001fd 1467                          cp      rFsmCurrentState, rFsmNextState
0001fe f409                          brne    FSM_15State5Red5_9Exit
0001ff c0da                          rjmp    FSM_99Exit
                                 
                                 FSM_15State5Red5_9Exit:
                                     ; Out startlights.
000200 2700                          clr     rAccu
000201 bb08                          out     ioLEDport, rAccu
                                 
                                     ; Jump to new state entry.
000202 c0d1                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 6 - race - track open.
                                     ; --------------------------------------------------------------------------
                                 FSM_16State6Grn_0Entry:
                                     ; Set new state.
000203 e006                          ldi     rAccu, fsmState6Grn
000204 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
000205 e002                          ldi     rAccu, (1<<ioLEDgreen)
000206 bb08                          out     ioLEDport, rAccu
                                 
                                 FSM_16State6Grn_1Run:
                                     ; Check exit conditions.
000207 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_16State6Grn_1Run_1:
                                     ; Check if countdown 5 - track closed - prepare for start.
000208 ff24                          sbrs    rTransfer, flProgStartLights
000209 c008                          rjmp    FSM_16State6Grn_1Run_2
00020a 2f02                          mov     rAccu, rTransfer
00020b 7007                          andi    rAccu, mskProgValues            ; Mask values
00020c 3005                          cpi     rAccu, 0x05                     ; 5 LED on
00020d f421                          brne    FSM_16State6Grn_1Run_2
00020e e015                          ldi     rScratch, fsmState5Red5
                                     ; Check if chaos.
00020f ff54                          sbrs    rFsmRacing, 4
000210 c001                          rjmp    FSM_16State6Grn_1Run_2
000211 e01a                          ldi     rScratch, fsmState10Chaos
                                 
                                 FSM_16State6Grn_1Run_2:
                                     ; Check if pacecar.
000212 ff26                          sbrs    rTransfer, flProgPaceCar
000213 c005                          rjmp    FSM_16State6Grn_1Run_3
000214 2f02                          mov     rAccu, rTransfer
000215 7001                          andi    rAccu, 0x01                     ; Mask pacecar bit
000216 3001                          cpi     rAccu, 0x01                     ; Check pacecar
000217 f409                          brne    FSM_16State6Grn_1Run_3
000218 e017                          ldi     rScratch, fsmState7Yel1
                                 
                                 FSM_16State6Grn_1Run_3:
                                     ; Check if early start.
000219 fd25                          sbrc    rTransfer, flProgEarlyStart
00021a e018                          ldi     rScratch, fsmState8Yel2
                                 
                                 FSM_16State6Grn_1Run_4:
                                     ; Check if race finished.
00021b fd23                          sbrc    rTransfer, flProgFinished
00021c e019                          ldi     rScratch, fsmState9RFin
                                 
                                 FSM_16State6Grn_1Run_5:
                                     ; Check if reset.
00021d fd27                          sbrc    rTransfer, flProgReset
00021e e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_16State6Grn_1Run_9:
                                     ; If a new state is set, exit the current state.
00021f 2e71                          mov     rFsmNextState, rScratch
000220 1467                          cp      rFsmCurrentState, rFsmNextState
000221 f409                          brne    FSM_16State6Grn_9Exit
000222 c0b7                          rjmp    FSM_99Exit
                                 
                                 FSM_16State6Grn_9Exit:
                                     ; Out startlights.
000223 2700                          clr     rAccu
000224 bb08                          out     ioLEDport, rAccu
                                     ; Jump to new state entry.
000225 c0ae                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 7 - Pacecar.
                                     ; --------------------------------------------------------------------------
                                 FSM_17State7Yel1_0Entry:
                                     ; Set new state.
000226 e007                          ldi     rAccu, fsmState7Yel1
000227 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
                                     ; Reload timer so that first blink period starts completely with lights on.
000228 b709
000229 6000
00022a bf09
00022b e408
00022c bd0d
00022d ee05
00022e bd0c
00022f b709
000230 6800
000231 bf09                          mac_MAIN_TIMER1restart
000232 9ac0                          sbi     ioLEDport, ioLEDyellow
000233 e001                          ldi     rAccu, (1<<ioLEDyellow)
000234 2a80                          or      rBlinkMask, rAccu
                                 
                                 FSM_17State7Yel1_1Run:
                                     ; Check exit conditions.
000235 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_17State7Yel1_1Run_1:
                                     ; Check pacecar.
000236 ff26                          sbrs    rTransfer, flProgPaceCar
000237 c005                          rjmp    FSM_17State7Yel1_1Run_2
000238 2f02                          mov     rAccu, rTransfer
000239 7001                          andi    rAccu, 0x01                     ; Mask pacecar bit
00023a 3000                          cpi     rAccu, 0x00                     ; Check pacecar
00023b f409                          brne    FSM_17State7Yel1_1Run_2
00023c e016                          ldi     rScratch, fsmState6Grn
                                 
                                 FSM_17State7Yel1_1Run_2:
                                     ; Reset.
00023d fd27                          sbrc    rTransfer, flProgReset
00023e e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_17State7Yel1_1Run_9:
                                     ; If a new state is set, exit the current state.
00023f 2e71                          mov     rFsmNextState, rScratch
000240 1467                          cp      rFsmCurrentState, rFsmNextState
000241 f409                          brne    FSM_17State7Yel1_9Exit
000242 c097                          rjmp    FSM_99Exit
                                 
                                 FSM_17State7Yel1_9Exit:
                                     ; Out startlights.
000243 e001                          ldi     rAccu, (1<<ioLEDyellow)
000244 9500                          com     rAccu
000245 2280                          and     rBlinkMask, rAccu
000246 98c0                          cbi     ioLEDport, ioLEDyellow
                                     ; Jump to new state entry.
000247 c08c                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 8 - Early start.
                                     ; --------------------------------------------------------------------------
                                 FSM_18State8Yel2_0Entry:
                                     ; Set new state.
000248 e008                          ldi     rAccu, fsmState8Yel2
000249 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
00024a 9ac0                          sbi     ioLEDport, ioLEDyellow
                                     ; Move bit for LED row to
                                     ; number of controller/slotcar with early start.
00024b 2f02                          mov     rAccu, rTransfer
00024c 7007                          andi    rAccu, mskProgValues            ; Mask values
00024d e410                          ldi     rScratch, (1<<ioEarlyStart1st)
                                     ; If controller/slotcar 6 then select red led row (1+5=6)
                                     ; because there are only 5 led rows available.
00024e 3005                          cpi     rAccu, 5
00024f f411                          brne    FSM_18State8Yel2_0Entry_1SlotcarLoop
000250 e414                          ldi     rScratch, (1<<ioLEDred1) | (1<<ioLEDred5)
000251 c005                          rjmp    FSM_18State8Yel2_0Entry_2SlotcarEnd
                                 
                                 FSM_18State8Yel2_0Entry_1SlotcarLoop:
000252 2300                          tst     rAccu
000253 f019                          breq    FSM_18State8Yel2_0Entry_2SlotcarEnd
000254 950a                          dec     rAccu
                                     ; Rotate according to configuration (main.inc).
                                 .if  ioEarlyStartDir == 1
                                 .else
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\fsm.asm(654): Early start-rotation set to LSR
                                     .message "Early start-rotation set to LSR"
000255 9516                          lsr     rScratch
                                 .endif
000256 cffb                          rjmp    FSM_18State8Yel2_0Entry_1SlotcarLoop
                                 
                                 FSM_18State8Yel2_0Entry_2SlotcarEnd:
                                     ; Out startlights.
                                     ; Reload timer so that first blink period starts completly with lights on.
000257 b709
000258 6000
000259 bf09
00025a e408
00025b bd0d
00025c ee05
00025d bd0c
00025e b709
00025f 6800
000260 bf09                          mac_MAIN_TIMER1restart              ; rAccu will be changed, rScratch not
000261 2e81                          mov     rBlinkMask, rScratch
000262 b308                          in      rAccu, ioLEDport
000263 2b01                          or      rAccu, rScratch
000264 bb08                          out     ioLEDport, rAccu
                                 
                                 FSM_18State8Yel2_1Run:
                                     ; Check exit conditions.
000265 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_18State8Yel2_1Run_1:
                                     ; Countdown 0 - race - track open.
000266 ff24                          sbrs    rTransfer, flProgStartLights
000267 cf1c                          rjmp    FSM_11State1Red1_1Run_1
000268 2f02                          mov     rAccu, rTransfer
000269 7007                          andi    rAccu, mskProgValues            ; Mask values
00026a 3000                          cpi     rAccu, 0x00                     ; All LED off
00026b f409                          brne    FSM_18State8Yel2_1Run_2
00026c e016                          ldi     rScratch, fsmState6Grn
                                 
                                 FSM_18State8Yel2_1Run_2:
                                    ; Check if countdown 5 - track closed - chaos - prepare start.
00026d ff24                          sbrs    rTransfer, flProgStartLights
00026e c005                          rjmp    FSM_18State8Yel2_1Run_3
00026f 2f02                          mov     rAccu, rTransfer
000270 7007                          andi    rAccu, mskProgValues            ; Mask values
000271 3005                          cpi     rAccu, 0x05                     ; 5 LED on
000272 f409                          brne    FSM_18State8Yel2_1Run_3
000273 e015                          ldi     rScratch, fsmState5Red5
                                 
                                 FSM_18State8Yel2_1Run_3:
                                     ; Check if reset.
000274 fd27                          sbrc    rTransfer, flProgReset
000275 e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_18State8Yel2_1Run_9:
                                     ; If a new state is set, exit the current state.
000276 2e71                          mov     rFsmNextState, rScratch
000277 1467                          cp      rFsmCurrentState, rFsmNextState
000278 f409                          brne    FSM_18State8Yel2_9Exit
000279 c060                          rjmp    FSM_99Exit
                                 
                                 FSM_18State8Yel2_9Exit:
                                     ; Out startlights.
00027a 2700                          clr     rAccu
00027b 2e80                          mov     rBlinkMask, rAccu
00027c bb08                          out     ioLEDport, rAccu
                                     ; Jump to new state entry
00027d c056                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 9 - Race finished.
                                     ; --------------------------------------------------------------------------
                                 FSM_19State9RFin_0Entry:
                                     ; Set new state.
00027e e009                          ldi     rAccu, fsmState9RFin
00027f 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Clear Racing State
000280 2755                          clr     rFsmRacing
                                     ; Out startlights.
000281 b709
000282 6000
000283 bf09
000284 e408
000285 bd0d
000286 ee05
000287 bd0c
000288 b709
000289 6800
00028a bf09                          mac_MAIN_TIMER1restart
00028b 9ac1                          sbi     ioLEDport, ioLEDgreen
00028c e002                          ldi     rAccu, (1<<ioLEDgreen)
00028d 2a80                          or      rBlinkMask, rAccu
                                 
                                     ; Move bit for LED row to
                                     ; number of controller/slotcar with early start.
00028e 2f02                          mov     rAccu, rTransfer
00028f 7007                          andi    rAccu, mskProgValues            ; Mask values
000290 e410                          ldi     rScratch, (1<<ioEarlyStart1st)
                                     ; If controller/slotcar 6 then select red led row (1+5=6)
                                     ; because there are only 5 led rows available.
000291 3005                          cpi     rAccu, 5
000292 f411                          brne    FSM_19State9RFin_0Entry_1SlotcarLoop
000293 e414                          ldi     rScratch, (1<<ioLEDred1) | (1<<ioLEDred5)
000294 c005                          rjmp    FSM_19State9RFin_0Entry_2SlotcarEnd
                                 
                                 FSM_19State9RFin_0Entry_1SlotcarLoop:
000295 2300                          tst     rAccu
000296 f019                          breq    FSM_19State9RFin_0Entry_2SlotcarEnd
000297 950a                          dec     rAccu
                                     ; Rotate according to configuration (main.inc).
                                 .if  ioEarlyStartDir == 1
                                 .else
D:\Daten\A.Wahl\GIT\Startlights_Software_Priv\Startlights-V1\fsm.asm(748): Winner-rotation set to LSR
                                     .message "Winner-rotation set to LSR"
000298 9516                          lsr     rScratch
                                 .endif
000299 cffb                          rjmp    FSM_19State9RFin_0Entry_1SlotcarLoop
                                 
                                 FSM_19State9RFin_0Entry_2SlotcarEnd:
                                     ; Out startlights.
00029a b308                          in      rAccu, ioLEDport
00029b 2b01                          or      rAccu, rScratch
00029c bb08                          out     ioLEDport, rAccu
                                 
                                 FSM_19State9RFin_1Run:
                                     ; Check exit conditions.
00029d 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_19State9RFin_1Run_1:
                                    ; Check if countdown 5 - track closed - chaos - prepare start.
00029e ff24                          sbrs    rTransfer, flProgStartLights
00029f c005                          rjmp    FSM_19State9RFin_1Run_2
0002a0 2f02                          mov     rAccu, rTransfer
0002a1 7007                          andi    rAccu, mskProgValues            ; Mask values
0002a2 3005                          cpi     rAccu, 0x05                     ; 5 LED on
0002a3 f409                          brne    FSM_19State9RFin_1Run_2
0002a4 e015                          ldi     rScratch, fsmState5Red5
                                 
                                 FSM_19State9RFin_1Run_2:
                                     ; Check if reset.
0002a5 fd27                          sbrc    rTransfer, flProgReset
0002a6 e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_19State9RFin_1Run_9:
                                     ; If a new state is set, exit the current state.
0002a7 2e71                          mov     rFsmNextState, rScratch
0002a8 1467                          cp      rFsmCurrentState, rFsmNextState
0002a9 f409                          brne    FSM_19State9RFin_9Exit
0002aa c02f                          rjmp    FSM_99Exit
                                 
                                 FSM_19State9RFin_9Exit:
                                     ; Out startlights.
0002ab 2700                          clr     rAccu
0002ac 2e80                          mov     rBlinkMask, rAccu
0002ad bb08                          out     ioLEDport, rAccu
                                     ; Jump to new state entry.
0002ae c025                          rjmp    FSM_98ChangeState
                                 
                                     ; --------------------------------------------------------------------------
                                     ; State 10 - CHAOS
                                     ; --------------------------------------------------------------------------
                                 FSM_20State10Chaos_0Entry:
                                     ; Set new state.
0002af e00a                          ldi     rAccu, fsmState10Chaos
0002b0 2e60                          mov     rFsmCurrentState, rAccu
                                     ; Out startlights.
                                     ; Reload timer so that first blink period starts completely with lights on.
0002b1 b709
0002b2 6000
0002b3 bf09
0002b4 e408
0002b5 bd0d
0002b6 ee05
0002b7 bd0c
0002b8 b709
0002b9 6800
0002ba bf09                          mac_MAIN_TIMER1restart
0002bb e70c                          ldi     rAccu, (1<<ioLEDred1) | (1<<ioLEDred2) | (1<<ioLEDred3) | (1<<ioLEDred4) | (1<<ioLEDred5)
0002bc bb08                          out     ioLEDport, rAccu
0002bd 2e80                          mov      rBlinkMask, rAccu
                                 
                                 FSM_20State10Chaos_1Run:
                                     ; Check exit conditions.
0002be 2d16                          mov     rScratch, rFsmCurrentState
                                 
                                 FSM_20State10Chaos_1Run_1:
                                     ; Check if countdown 0 - Race - Track open.
0002bf ff24                          sbrs    rTransfer, flProgStartLights
0002c0 c005                          rjmp    FSM_20State10Chaos_1Run_2
0002c1 2f02                          mov     rAccu, rTransfer
0002c2 7007                          andi    rAccu, mskProgValues            ; Mask values
0002c3 3000                          cpi     rAccu, 0x00                     ; All LED off
0002c4 f409                          brne    FSM_20State10Chaos_1Run_2
0002c5 e016                          ldi     rScratch, fsmState6Grn
                                 
                                 FSM_20State10Chaos_1Run_2:
                                     ; Check if countdown 1 - start countdown.
0002c6 3001                          cpi     rAccu, 0x01                     ; 1 LED on
0002c7 f409                          brne    FSM_20State10Chaos_1Run_3
0002c8 e011                          ldi     rScratch, fsmState1Red1
                                 
                                 FSM_20State10Chaos_1Run_3:
                                     ; Check if reset.
0002c9 fd27                          sbrc    rTransfer, flProgReset
0002ca e010                          ldi     rScratch, fsmState0Init
                                 
                                 FSM_20State10Chaos_1Run_9:
                                     ; If a new state is set, exit the current state.
0002cb 2e71                          mov     rFsmNextState, rScratch
0002cc 1467                          cp      rFsmCurrentState, rFsmNextState
0002cd f409                          brne    FSM_20State10Chaos_9Exit
0002ce c00b                          rjmp    FSM_99Exit
                                 
                                 FSM_20State10Chaos_9Exit:
                                     ; Out startlights.
0002cf e70c                          ldi     rAccu, (1<<ioLEDred1) | (1<<ioLEDred2) | (1<<ioLEDred3) | (1<<ioLEDred4) | (1<<ioLEDred5)
0002d0 9500                          com     rAccu
0002d1 2280                          and     rBlinkMask, rAccu
0002d2 bb08                          out     ioLEDport, rAccu
                                     ; Jump to new state entry.
0002d3 c000                          rjmp    FSM_98ChangeState
                                 
                                     ; ==========================================================================
                                 
                                     ; --------------------------------------------------------------------------
                                     ; FSM Change state / Next state.
                                     ; --------------------------------------------------------------------------
                                 FSM_98ChangeState:
                                     ; Jump to next state.
0002d4 e0f2                          ldi     ZH, HIGH (FSM_adrStateEntry)    ; Load jumptable address...
0002d5 eee1                          ldi     ZL, LOW (FSM_adrStateEntry)     ; ...to pointer.
0002d6 0de7                          add     ZL, rFsmNextState               ; Add state offset
0002d7 2700                          clr     rAccu
0002d8 1ff0                          adc     ZH, rAccu                       ; Consider carryflag
0002d9 9409                          ijmp                                    ; Jump to new state entry
                                 
                                     ; --------------------------------------------------------------------------
                                     ; FSM Exit.
                                     ; --------------------------------------------------------------------------
                                 FSM_99Exit:
                                 
                                     ; Restore SREG and registers from STACK.
0002da 910f                          pop     rAccu
0002db bf0f                          out     SREG, rAccu
0002dc 910f                          pop     rAccu
0002dd 911f                          pop     rScratch
0002de 91ff                          pop     ZH
0002df 91ef                          pop     ZL
                                 
                                     ; All done! Return.
0002e0 9508                          ret
                                 
                                     ; --------------------------------------------------------------------------
                                     ; FSM jump table - entry state.
                                     ; --------------------------------------------------------------------------
                                 FSM_adrStateEntry:
0002e1 ce7a                          rjmp    FSM_10State0Init_0Entry
0002e2 ce9b                          rjmp    FSM_11State1Red1_0Entry
0002e3 ceb5                          rjmp    FSM_12State2Red2_0Entry
0002e4 cecf                          rjmp    FSM_13State3Red3_0Entry
0002e5 cee9                          rjmp    FSM_14State4Red4_0Entry
0002e6 cf00                          rjmp    FSM_15State5Red5_0Entry
0002e7 cf1b                          rjmp    FSM_16State6Grn_0Entry
0002e8 cf3d                          rjmp    FSM_17State7Yel1_0Entry
0002e9 cf5e                          rjmp    FSM_18State8Yel2_0Entry
0002ea cf93                          rjmp    FSM_19State9RFin_0Entry
0002eb cfc3                          rjmp    FSM_20State10Chaos_0Entry
                                 
                                     ; --------------------------------------------------------------------------
                                     ; FSM jump table - running state.
                                     ; --------------------------------------------------------------------------
                                 FSM_adrStateRun:
0002ec ce74                          rjmp    FSM_10State0Init_1Run
0002ed ce95                          rjmp    FSM_11State1Red1_1Run
0002ee ceaf                          rjmp    FSM_12State2Red2_1Run
0002ef cec9                          rjmp    FSM_13State3Red3_1Run
0002f0 cee3                          rjmp    FSM_14State4Red4_1Run
0002f1 cefa                          rjmp    FSM_15State5Red5_1Run
0002f2 cf14                          rjmp    FSM_16State6Grn_1Run
0002f3 cf41                          rjmp    FSM_17State7Yel1_1Run
0002f4 cf70                          rjmp    FSM_18State8Yel2_1Run
0002f5 cfa7                          rjmp    FSM_19State9RFin_1Run


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny2313A" register use summary:
x  :   0 y  :   0 z  :  17 r0 :   0 r1 :   0 r2 :   7 r3 :   6 r4 :  10 
r5 :   6 r6 :  36 r7 :  26 r8 :  14 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 366 r17: 106 r18:  58 r19:   9 r20:   7 
r21:   9 r22:   0 r23:   0 r24:   0 r25:   0 r26:   0 r27:   0 r28:   0 
r29:   0 r30:  15 r31:  15 
Registers used: 16 out of 35 (45.7%)

"ATtiny2313A" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   3 add   :   3 adiw  :   0 and   :   3 
andi  :  28 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   1 break :   0 breq  :   5 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   3 brlt  :   0 brmi  :   0 
brne  :  45 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 cbi   :   7 cbr   :   7 clc   :   0 
clh   :   0 cli   :   0 cln   :   0 clr   :  36 cls   :   0 clt   :   0 
clv   :   0 clz   :   0 com   :   3 cp    :  14 cpc   :   0 cpi   :  34 
cpse  :   0 dec   :   3 eor   :   2 icall :   0 ijmp  :   2 in    :  32 
inc   :   3 ld    :   0 ldd   :  12 ldi   : 103 lds   :   0 lpm   :   0 
lsl   :   7 lsr   :   3 mov   :  66 movw  :   0 neg   :   0 nop   :   0 
or    :   5 ori   :   1 out   :  68 pop   :  22 push  :  27 rcall :   4 
ret   :   2 reti  :   4 rjmp  :  82 rol   :  11 ror   :  11 sbc   :   0 
sbci  :   0 sbi   :   5 sbic  :   1 sbis  :   2 sbiw  :   0 sbr   :  22 
sbrc  :  19 sbrs  :  18 sec   :   0 seh   :   0 sei   :   1 sen   :   0 
ser   :   1 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :   5 std   :   0 sts   :   0 sub   :   0 subi  :   1 
swap  :   0 tst   :   5 wdr   :   0 
Instructions used: 46 out of 105 (43.8%)

"ATtiny2313A" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0005ee   1484      0   1484    2048  72.5%
[.dseg] 0x000060 0x00008c      0     44     44     128  34.4%
[.eseg] 0x000000 0x000000      0      0      0     128   0.0%

Assembly complete, 0 errors, 0 warnings
